// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"airbyte/internal/sdk"
	"context"
	"fmt"

	"airbyte/internal/sdk/pkg/models/operations"
	"airbyte/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &DestinationResource{}
var _ resource.ResourceWithImportState = &DestinationResource{}

func NewDestinationResource() resource.Resource {
	return &DestinationResource{}
}

// DestinationResource defines the resource implementation.
type DestinationResource struct {
	client *sdk.SDK
}

// DestinationResourceModel describes the resource data model.
type DestinationResourceModel struct {
	Configuration   DestinationConfiguration `tfsdk:"configuration"`
	DestinationID   types.String             `tfsdk:"destination_id"`
	DestinationType types.String             `tfsdk:"destination_type"`
	Name            types.String             `tfsdk:"name"`
	WorkspaceID     types.String             `tfsdk:"workspace_id"`
}

func (r *DestinationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_destination"
}

func (r *DestinationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Destination Resource",

		Attributes: map[string]schema.Attribute{
			"configuration": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"destination_amazon_sqs": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"amazon-sqs",
									),
								},
							},
							"message_body_key": schema.StringAttribute{
								Computed: true,
							},
							"message_delay": schema.Int64Attribute{
								Computed: true,
							},
							"message_group_id": schema.StringAttribute{
								Computed: true,
							},
							"queue_url": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `AWS Region of the SQS Queue`,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_aws_datalake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"aws_account_id": schema.StringAttribute{
								Computed: true,
							},
							"bucket_name": schema.StringAttribute{
								Computed: true,
							},
							"bucket_prefix": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_aws_datalake_authentication_mode_iam_role": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"IAM Role",
													),
												},
												Description: `Name of the credentials`,
											},
											"role_arn": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose How to Authenticate to AWS.`,
									},
									"destination_aws_datalake_authentication_mode_iam_user": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"aws_access_key_id": schema.StringAttribute{
												Computed: true,
											},
											"aws_secret_access_key": schema.StringAttribute{
												Computed: true,
											},
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"IAM User",
													),
												},
												Description: `Name of the credentials`,
											},
										},
										Description: `Choose How to Authenticate to AWS.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"aws-datalake",
									),
								},
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_aws_datalake_output_format_wildcard_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression_codec": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"UNCOMPRESSED",
														"GZIP",
													),
												},
												Description: `The compression algorithm used to compress data.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Format of the data output.`,
									},
									"destination_aws_datalake_output_format_wildcard_parquet_columnar_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression_codec": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"UNCOMPRESSED",
														"SNAPPY",
														"GZIP",
														"ZSTD",
													),
												},
												Description: `The compression algorithm used to compress data.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Parquet",
													),
												},
											},
										},
										Description: `Format of the data output.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"glue_catalog_float_as_decimal": schema.BoolAttribute{
								Computed: true,
							},
							"lakeformation_database_default_tag_key": schema.StringAttribute{
								Computed: true,
							},
							"lakeformation_database_default_tag_values": schema.StringAttribute{
								Computed: true,
							},
							"lakeformation_database_name": schema.StringAttribute{
								Computed: true,
							},
							"lakeformation_governed_tables": schema.BoolAttribute{
								Computed: true,
							},
							"partitioning": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NO PARTITIONING",
										"DATE",
										"YEAR",
										"MONTH",
										"DAY",
										"YEAR/MONTH",
										"YEAR/MONTH/DAY",
									),
								},
								Description: `Partition data by cursor fields when a cursor field is a date`,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.`,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_azure_blob_storage": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"azure_blob_storage_account_key": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_account_name": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_container_name": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_endpoint_domain_name": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_output_buffer_size": schema.Int64Attribute{
								Computed: true,
							},
							"azure_blob_storage_spill_size": schema.Int64Attribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"azure-blob-storage",
									),
								},
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_azure_blob_storage_output_format_csv_comma_separated_values": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"flattening": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"No flattening",
														"Root level flattening",
													),
												},
												Description: `Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CSV",
													),
												},
											},
										},
										Description: `Output data format`,
									},
									"destination_azure_blob_storage_output_format_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Output data format`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_bigquery": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"big_query_client_buffer_size_mb": schema.Int64Attribute{
								Computed: true,
							},
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"dataset_id": schema.StringAttribute{
								Computed: true,
							},
							"dataset_location": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"US",
										"EU",
										"asia-east1",
										"asia-east2",
										"asia-northeast1",
										"asia-northeast2",
										"asia-northeast3",
										"asia-south1",
										"asia-south2",
										"asia-southeast1",
										"asia-southeast2",
										"australia-southeast1",
										"australia-southeast2",
										"europe-central1",
										"europe-central2",
										"europe-north1",
										"europe-southwest1",
										"europe-west1",
										"europe-west2",
										"europe-west3",
										"europe-west4",
										"europe-west6",
										"europe-west7",
										"europe-west8",
										"europe-west9",
										"me-west1",
										"northamerica-northeast1",
										"northamerica-northeast2",
										"southamerica-east1",
										"southamerica-west1",
										"us-central1",
										"us-east1",
										"us-east2",
										"us-east3",
										"us-east4",
										"us-east5",
										"us-west1",
										"us-west2",
										"us-west3",
										"us-west4",
									),
								},
								Description: `The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>.`,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bigquery",
									),
								},
							},
							"loading_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_bigquery_loading_method_standard_inserts": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `Loading method used to send select the way data will be uploaded to BigQuery. <br/><b>Standard Inserts</b> - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. <br/><b>GCS Staging</b> - Writes large batches of records to a file, uploads the file to GCS, then uses <b>COPY INTO table</b> to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.`,
									},
									"destination_bigquery_loading_method_gcs_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"credential": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_bigquery_loading_method_gcs_staging_credential_hmac_key": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"credential_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"HMAC_KEY",
																	),
																},
															},
															"hmac_key_access_id": schema.StringAttribute{
																Computed: true,
															},
															"hmac_key_secret": schema.StringAttribute{
																Computed: true,
															},
														},
														Description: `An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"gcs_bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"gcs_bucket_path": schema.StringAttribute{
												Computed: true,
											},
											"keep_files_in_gcs_bucket": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Delete all tmp files from GCS",
														"Keep all tmp files in GCS",
													),
												},
												Description: `This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly.`,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"GCS Staging",
													),
												},
											},
										},
										Description: `Loading method used to send select the way data will be uploaded to BigQuery. <br/><b>Standard Inserts</b> - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. <br/><b>GCS Staging</b> - Writes large batches of records to a file, uploads the file to GCS, then uses <b>COPY INTO table</b> to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
							"transformation_priority": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"interactive",
										"batch",
									),
								},
								Description: `Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries don’t count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly.`,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_bigquery_denormalized": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"big_query_client_buffer_size_mb": schema.Int64Attribute{
								Computed: true,
							},
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"dataset_id": schema.StringAttribute{
								Computed: true,
							},
							"dataset_location": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"US",
										"EU",
										"asia-east1",
										"asia-east2",
										"asia-northeast1",
										"asia-northeast2",
										"asia-northeast3",
										"asia-south1",
										"asia-south2",
										"asia-southeast1",
										"asia-southeast2",
										"australia-southeast1",
										"australia-southeast2",
										"europe-central1",
										"europe-central2",
										"europe-north1",
										"europe-southwest1",
										"europe-west1",
										"europe-west2",
										"europe-west3",
										"europe-west4",
										"europe-west6",
										"europe-west7",
										"europe-west8",
										"europe-west9",
										"me-west1",
										"northamerica-northeast1",
										"northamerica-northeast2",
										"southamerica-east1",
										"southamerica-west1",
										"us-central1",
										"us-east1",
										"us-east2",
										"us-east3",
										"us-east4",
										"us-east5",
										"us-west1",
										"us-west2",
										"us-west3",
										"us-west4",
									),
								},
								Description: `The location of the dataset. Warning: Changes made after creation will not be applied. The default "US" value is used if not set explicitly. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>.`,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bigquery-denormalized",
									),
								},
							},
							"loading_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_bigquery_denormalized_loading_method_standard_inserts": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `Loading method used to send select the way data will be uploaded to BigQuery. <br/><b>Standard Inserts</b> - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. <br/><b>GCS Staging</b> - Writes large batches of records to a file, uploads the file to GCS, then uses <b>COPY INTO table</b> to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.`,
									},
									"destination_bigquery_denormalized_loading_method_gcs_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"credential": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_bigquery_denormalized_loading_method_gcs_staging_credential_hmac_key": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"credential_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"HMAC_KEY",
																	),
																},
															},
															"hmac_key_access_id": schema.StringAttribute{
																Computed: true,
															},
															"hmac_key_secret": schema.StringAttribute{
																Computed: true,
															},
														},
														Description: `An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"gcs_bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"gcs_bucket_path": schema.StringAttribute{
												Computed: true,
											},
											"keep_files_in_gcs_bucket": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Delete all tmp files from GCS",
														"Keep all tmp files in GCS",
													),
												},
												Description: `This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly.`,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"GCS Staging",
													),
												},
											},
										},
										Description: `Loading method used to send select the way data will be uploaded to BigQuery. <br/><b>Standard Inserts</b> - Direct uploading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In almost all cases, you should use staging. <br/><b>GCS Staging</b> - Writes large batches of records to a file, uploads the file to GCS, then uses <b>COPY INTO table</b> to upload the file. Recommended for most workloads for better speed and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_cassandra": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"address": schema.StringAttribute{
								Computed: true,
							},
							"datacenter": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"cassandra",
									),
								},
							},
							"keyspace": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication": schema.Int64Attribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_clickhouse": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"clickhouse",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_clickhouse_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_clickhouse_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_clickhouse_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_convex": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"deployment_url": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"convex",
									),
								},
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_databend": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"databend",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"table": schema.StringAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_databricks": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"accept_terms": schema.BoolAttribute{
								Computed: true,
							},
							"data_source": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_databricks_data_source_recommended_managed_tables": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"data_source_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"MANAGED_TABLES_STORAGE",
													),
												},
											},
										},
										Description: `Storage on which the delta lake is built.`,
									},
									"destination_databricks_data_source_amazon_s3": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"data_source_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"S3_STORAGE",
													),
												},
											},
											"file_name_pattern": schema.StringAttribute{
												Computed: true,
											},
											"s3_access_key_id": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_path": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_region": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"us-east-1",
														"us-east-2",
														"us-west-1",
														"us-west-2",
														"af-south-1",
														"ap-east-1",
														"ap-south-1",
														"ap-northeast-1",
														"ap-northeast-2",
														"ap-northeast-3",
														"ap-southeast-1",
														"ap-southeast-2",
														"ca-central-1",
														"cn-north-1",
														"cn-northwest-1",
														"eu-central-1",
														"eu-north-1",
														"eu-south-1",
														"eu-west-1",
														"eu-west-2",
														"eu-west-3",
														"sa-east-1",
														"me-south-1",
														"us-gov-east-1",
														"us-gov-west-1",
													),
												},
												Description: `The region of the S3 staging bucket to use if utilising a copy strategy.`,
											},
											"s3_secret_access_key": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Storage on which the delta lake is built.`,
									},
									"destination_databricks_data_source_azure_blob_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"azure_blob_storage_account_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_container_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_endpoint_domain_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_sas_token": schema.StringAttribute{
												Computed: true,
											},
											"data_source_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"AZURE_BLOB_STORAGE",
													),
												},
											},
										},
										Description: `Storage on which the delta lake is built.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"databricks_http_path": schema.StringAttribute{
								Computed: true,
							},
							"databricks_personal_access_token": schema.StringAttribute{
								Computed: true,
							},
							"databricks_port": schema.StringAttribute{
								Computed: true,
							},
							"databricks_server_hostname": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"databricks",
									),
								},
							},
							"purge_staging_data": schema.BoolAttribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_dynamodb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key_id": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"dynamodb",
									),
								},
							},
							"dynamodb_endpoint": schema.StringAttribute{
								Computed: true,
							},
							"dynamodb_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `The region of the DynamoDB.`,
							},
							"dynamodb_table_name_prefix": schema.StringAttribute{
								Computed: true,
							},
							"secret_access_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_elasticsearch": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"authentication_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_elasticsearch_authentication_method_api_key_secret": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_key_id": schema.StringAttribute{
												Computed: true,
											},
											"api_key_secret": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"secret",
													),
												},
											},
										},
										Description: `Use a api key and secret combination to authenticate`,
									},
									"destination_elasticsearch_authentication_method_username_password": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
													),
												},
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"username": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Basic auth header with a username and password`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"ca_certificate": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"elasticsearch",
									),
								},
							},
							"endpoint": schema.StringAttribute{
								Computed: true,
							},
							"upsert": schema.BoolAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_firebolt": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account": schema.StringAttribute{
								Computed: true,
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"firebolt",
									),
								},
							},
							"engine": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"loading_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_firebolt_loading_method_sql_inserts": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SQL",
													),
												},
											},
										},
										Description: `Loading method used to select the way data will be uploaded to Firebolt`,
									},
									"destination_firebolt_loading_method_external_table_via_s3": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"aws_key_id": schema.StringAttribute{
												Computed: true,
											},
											"aws_key_secret": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"S3",
													),
												},
											},
											"s3_bucket": schema.StringAttribute{
												Computed: true,
											},
											"s3_region": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Loading method used to select the way data will be uploaded to Firebolt`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_firestore": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"firestore",
									),
								},
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_gcs": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credential": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_gcs_authentication_hmac_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"credential_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"HMAC_KEY",
													),
												},
											},
											"hmac_key_access_id": schema.StringAttribute{
												Computed: true,
											},
											"hmac_key_secret": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gcs",
									),
								},
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_gcs_output_format_avro_apache_avro": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression_codec": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_gcs_output_format_avro_apache_avro_compression_codec_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"no compression",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_gcs_output_format_avro_apache_avro_compression_codec_deflate": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"Deflate",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_gcs_output_format_avro_apache_avro_compression_codec_bzip2": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"bzip2",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_gcs_output_format_avro_apache_avro_compression_codec_xz": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"xz",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_gcs_output_format_avro_apache_avro_compression_codec_zstandard": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"zstandard",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
															"include_checksum": schema.BoolAttribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_gcs_output_format_avro_apache_avro_compression_codec_snappy": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"snappy",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Avro",
													),
												},
											},
										},
										Description: `Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.`,
									},
									"destination_gcs_output_format_csv_comma_separated_values": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_gcs_output_format_csv_comma_separated_values_compression_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"No Compression",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").`,
													},
													"destination_gcs_output_format_csv_comma_separated_values_compression_gzip": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"GZIP",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"flattening": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"No flattening",
														"Root level flattening",
													),
												},
												Description: `Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CSV",
													),
												},
											},
										},
										Description: `Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.`,
									},
									"destination_gcs_output_format_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_gcs_output_format_json_lines_newline_delimited_json_compression_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"No Compression",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
													"destination_gcs_output_format_json_lines_newline_delimited_json_compression_gzip": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"GZIP",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.`,
									},
									"destination_gcs_output_format_parquet_columnar_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"block_size_mb": schema.Int64Attribute{
												Computed: true,
											},
											"compression_codec": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"UNCOMPRESSED",
														"SNAPPY",
														"GZIP",
														"LZO",
														"BROTLI",
														"LZ4",
														"ZSTD",
													),
												},
												Description: `The compression algorithm used to compress data pages.`,
											},
											"dictionary_encoding": schema.BoolAttribute{
												Computed: true,
											},
											"dictionary_page_size_kb": schema.Int64Attribute{
												Computed: true,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Parquet",
													),
												},
											},
											"max_padding_size_mb": schema.Int64Attribute{
												Computed: true,
											},
											"page_size_kb": schema.Int64Attribute{
												Computed: true,
											},
										},
										Description: `Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"gcs_bucket_name": schema.StringAttribute{
								Computed: true,
							},
							"gcs_bucket_path": schema.StringAttribute{
								Computed: true,
							},
							"gcs_bucket_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"northamerica-northeast1",
										"northamerica-northeast2",
										"us-central1",
										"us-east1",
										"us-east4",
										"us-west1",
										"us-west2",
										"us-west3",
										"us-west4",
										"southamerica-east1",
										"southamerica-west1",
										"europe-central2",
										"europe-north1",
										"europe-west1",
										"europe-west2",
										"europe-west3",
										"europe-west4",
										"europe-west6",
										"asia-east1",
										"asia-east2",
										"asia-northeast1",
										"asia-northeast2",
										"asia-northeast3",
										"asia-south1",
										"asia-south2",
										"asia-southeast1",
										"asia-southeast2",
										"australia-southeast1",
										"australia-southeast2",
										"asia",
										"eu",
										"us",
										"asia1",
										"eur4",
										"nam4",
									),
								},
								Description: `Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.`,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_google_sheets": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"client_id": schema.StringAttribute{
										Computed: true,
									},
									"client_secret": schema.StringAttribute{
										Computed: true,
									},
									"refresh_token": schema.StringAttribute{
										Computed: true,
									},
								},
								Description: `Google API Credentials for connecting to Google Sheets and Google Drive APIs`,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-sheets",
									),
								},
							},
							"spreadsheet_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_keen": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"keen",
									),
								},
							},
							"infer_timestamp": schema.BoolAttribute{
								Computed: true,
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_kinesis": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"buffer_size": schema.Int64Attribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"kinesis",
									),
								},
							},
							"endpoint": schema.StringAttribute{
								Computed: true,
							},
							"private_key": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
							},
							"shard_count": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_mariadb_columnstore": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mariadb-columnstore",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mariadb_columnstore_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mariadb_columnstore_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mariadb_columnstore_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_meilisearch": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"meilisearch",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_mongodb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mongodb_authorization_type_none": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"authorization": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"none",
													),
												},
											},
										},
										Description: `None.`,
									},
									"destination_mongodb_authorization_type_login_password": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"authorization": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"login/password",
													),
												},
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"username": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Login/Password.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mongodb",
									),
								},
							},
							"instance_type": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mongodb_mongo_db_instance_type_standalone_mongo_db_instance": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"standalone",
													),
												},
											},
											"port": schema.Int64Attribute{
												Computed: true,
											},
										},
										Description: `MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
									"destination_mongodb_mongo_db_instance_type_replica_set": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"replica",
													),
												},
											},
											"replica_set": schema.StringAttribute{
												Computed: true,
											},
											"server_addresses": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
									"destination_mongodb_mongo_db_instance_type_mongo_db_atlas": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"cluster_url": schema.StringAttribute{
												Computed: true,
											},
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"atlas",
													),
												},
											},
										},
										Description: `MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mongodb_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mongodb_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mongodb_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_mssql": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mssql",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"ssl_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mssql_ssl_method_encrypted_trust_server_certificate_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssl_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"encrypted_trust_server_certificate",
													),
												},
											},
										},
										Description: `Use the certificate provided by the server without verification. (For testing purposes only!)`,
									},
									"destination_mssql_ssl_method_encrypted_verify_certificate_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host_name_in_certificate": schema.StringAttribute{
												Computed: true,
											},
											"ssl_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"encrypted_verify_certificate",
													),
												},
											},
										},
										Description: `Verify and use the certificate provided by the server.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mssql_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mssql_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mssql_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_mysql": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mysql",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_mysql_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mysql_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_mysql_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_oracle": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"oracle",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"sid": schema.StringAttribute{
								Computed: true,
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_oracle_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_oracle_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_oracle_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_postgres": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"postgres",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"ssl_mode": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_postgres_ssl_modes_disable": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"disable",
													),
												},
											},
										},
										Description: `Disable SSL.`,
									},
									"destination_postgres_ssl_modes_allow": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"allow",
													),
												},
											},
										},
										Description: `Allow SSL mode.`,
									},
									"destination_postgres_ssl_modes_prefer": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"prefer",
													),
												},
											},
										},
										Description: `Prefer SSL mode.`,
									},
									"destination_postgres_ssl_modes_require": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"require",
													),
												},
											},
										},
										Description: `Require SSL mode.`,
									},
									"destination_postgres_ssl_modes_verify_ca": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-ca",
													),
												},
											},
										},
										Description: `Verify-ca SSL mode.`,
									},
									"destination_postgres_ssl_modes_verify_full": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-full",
													),
												},
											},
										},
										Description: `Verify-full SSL mode.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_postgres_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_postgres_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_postgres_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_pubsub": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"batching_delay_threshold": schema.Int64Attribute{
								Computed: true,
							},
							"batching_element_count_threshold": schema.Int64Attribute{
								Computed: true,
							},
							"batching_enabled": schema.BoolAttribute{
								Computed: true,
							},
							"batching_request_bytes_threshold": schema.Int64Attribute{
								Computed: true,
							},
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pubsub",
									),
								},
							},
							"ordering_enabled": schema.BoolAttribute{
								Computed: true,
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
							"topic_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_pulsar": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"batching_enabled": schema.BoolAttribute{
								Computed: true,
							},
							"batching_max_messages": schema.Int64Attribute{
								Computed: true,
							},
							"batching_max_publish_delay": schema.Int64Attribute{
								Computed: true,
							},
							"block_if_queue_full": schema.BoolAttribute{
								Computed: true,
							},
							"brokers": schema.StringAttribute{
								Computed: true,
							},
							"compression_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NONE",
										"LZ4",
										"ZLIB",
										"ZSTD",
										"SNAPPY",
									),
								},
								Description: `Compression type for the producer.`,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pulsar",
									),
								},
							},
							"max_pending_messages": schema.Int64Attribute{
								Computed: true,
							},
							"max_pending_messages_across_partitions": schema.Int64Attribute{
								Computed: true,
							},
							"producer_name": schema.StringAttribute{
								Computed: true,
							},
							"producer_sync": schema.BoolAttribute{
								Computed: true,
							},
							"send_timeout_ms": schema.Int64Attribute{
								Computed: true,
							},
							"topic_namespace": schema.StringAttribute{
								Computed: true,
							},
							"topic_pattern": schema.StringAttribute{
								Computed: true,
							},
							"topic_tenant": schema.StringAttribute{
								Computed: true,
							},
							"topic_test": schema.StringAttribute{
								Computed: true,
							},
							"topic_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"persistent",
										"non-persistent",
									),
								},
								Description: `It identifies type of topic. Pulsar supports two kind of topics: persistent and non-persistent. In persistent topic, all messages are durably persisted on disk (that means on multiple disks unless the broker is standalone), whereas non-persistent topic does not persist message into storage disk.`,
							},
							"use_tls": schema.BoolAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_rabbitmq": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"rabbitmq",
									),
								},
							},
							"exchange": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"routing_key": schema.StringAttribute{
								Computed: true,
							},
							"ssl": schema.BoolAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
							"virtual_host": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_redis": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"cache_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"hash",
									),
								},
								Description: `Redis cache type to store data in.`,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"redis",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"ssl": schema.BoolAttribute{
								Computed: true,
							},
							"ssl_mode": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_redis_ssl_modes_disable": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"disable",
													),
												},
											},
										},
										Description: `Disable SSL.`,
									},
									"destination_redis_ssl_modes_verify_full": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-full",
													),
												},
											},
										},
										Description: `Verify-full SSL mode.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_redis_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_redis_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_redis_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_redshift": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"redshift",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_redshift_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_redshift_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"destination_redshift_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"uploading_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_redshift_uploading_method_standard": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `The method how the data will be uploaded to the database.`,
									},
									"destination_redshift_uploading_method_s3_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_key_id": schema.StringAttribute{
												Computed: true,
											},
											"encryption": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_redshift_uploading_method_s3_staging_encryption_no_encryption": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"encryption_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"none",
																	),
																},
															},
														},
														Description: `Staging data will be stored in plaintext.`,
													},
													"destination_redshift_uploading_method_s3_staging_encryption_aes_cbc_envelope_encryption": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"encryption_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"aes_cbc_envelope",
																	),
																},
															},
															"key_encrypting_key": schema.StringAttribute{
																Computed: true,
															},
														},
														Description: `Staging data will be encrypted using AES-CBC envelope encryption.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"file_buffer_count": schema.Int64Attribute{
												Computed: true,
											},
											"file_name_pattern": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"S3 Staging",
													),
												},
											},
											"purge_staging_data": schema.BoolAttribute{
												Computed: true,
											},
											"s3_bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_path": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_region": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"us-east-1",
														"us-east-2",
														"us-west-1",
														"us-west-2",
														"af-south-1",
														"ap-east-1",
														"ap-south-1",
														"ap-northeast-1",
														"ap-northeast-2",
														"ap-northeast-3",
														"ap-southeast-1",
														"ap-southeast-2",
														"ca-central-1",
														"cn-north-1",
														"cn-northwest-1",
														"eu-central-1",
														"eu-north-1",
														"eu-south-1",
														"eu-west-1",
														"eu-west-2",
														"eu-west-3",
														"sa-east-1",
														"me-south-1",
													),
												},
												Description: `The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.`,
											},
											"secret_access_key": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The method how the data will be uploaded to the database.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_rockset": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"api_server": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"rockset",
									),
								},
							},
							"workspace": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_s3": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key_id": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"s3",
									),
								},
							},
							"file_name_pattern": schema.StringAttribute{
								Computed: true,
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_s3_output_format_avro_apache_avro": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression_codec": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_s3_output_format_avro_apache_avro_compression_codec_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"no compression",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_s3_output_format_avro_apache_avro_compression_codec_deflate": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"Deflate",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_s3_output_format_avro_apache_avro_compression_codec_bzip2": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"bzip2",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_s3_output_format_avro_apache_avro_compression_codec_xz": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"xz",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_s3_output_format_avro_apache_avro_compression_codec_zstandard": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"zstandard",
																	),
																},
															},
															"compression_level": schema.Int64Attribute{
																Computed: true,
															},
															"include_checksum": schema.BoolAttribute{
																Computed: true,
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
													"destination_s3_output_format_avro_apache_avro_compression_codec_snappy": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"codec": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"snappy",
																	),
																},
															},
														},
														Description: `The compression algorithm used to compress data. Default to no compression.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Avro",
													),
												},
											},
										},
										Description: `Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details`,
									},
									"destination_s3_output_format_csv_comma_separated_values": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_s3_output_format_csv_comma_separated_values_compression_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"No Compression",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").`,
													},
													"destination_s3_output_format_csv_comma_separated_values_compression_gzip": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"GZIP",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"flattening": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"No flattening",
														"Root level flattening",
													),
												},
												Description: `Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CSV",
													),
												},
											},
										},
										Description: `Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details`,
									},
									"destination_s3_output_format_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_s3_output_format_json_lines_newline_delimited_json_compression_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"No Compression",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
													"destination_s3_output_format_json_lines_newline_delimited_json_compression_gzip": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"GZIP",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"flattening": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"No flattening",
														"Root level flattening",
													),
												},
												Description: `Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details`,
									},
									"destination_s3_output_format_parquet_columnar_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"block_size_mb": schema.Int64Attribute{
												Computed: true,
											},
											"compression_codec": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"UNCOMPRESSED",
														"SNAPPY",
														"GZIP",
														"LZO",
														"BROTLI",
														"LZ4",
														"ZSTD",
													),
												},
												Description: `The compression algorithm used to compress data pages.`,
											},
											"dictionary_encoding": schema.BoolAttribute{
												Computed: true,
											},
											"dictionary_page_size_kb": schema.Int64Attribute{
												Computed: true,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Parquet",
													),
												},
											},
											"max_padding_size_mb": schema.Int64Attribute{
												Computed: true,
											},
											"page_size_kb": schema.Int64Attribute{
												Computed: true,
											},
										},
										Description: `Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"s3_bucket_name": schema.StringAttribute{
								Computed: true,
							},
							"s3_bucket_path": schema.StringAttribute{
								Computed: true,
							},
							"s3_bucket_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.`,
							},
							"s3_endpoint": schema.StringAttribute{
								Computed: true,
							},
							"s3_path_format": schema.StringAttribute{
								Computed: true,
							},
							"secret_access_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_s3_glue": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key_id": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"s3-glue",
									),
								},
							},
							"file_name_pattern": schema.StringAttribute{
								Computed: true,
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_s3_glue_output_format_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"compression": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_s3_glue_output_format_json_lines_newline_delimited_json_compression_no_compression": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"No Compression",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
													"destination_s3_glue_output_format_json_lines_newline_delimited_json_compression_gzip": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"compression_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"GZIP",
																	),
																},
															},
														},
														Description: `Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"flattening": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"No flattening",
														"Root level flattening",
													),
												},
												Description: `Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.`,
											},
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"glue_database": schema.StringAttribute{
								Computed: true,
							},
							"glue_serialization_library": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"org.openx.data.jsonserde.JsonSerDe",
										"org.apache.hive.hcatalog.data.JsonSerDe",
									),
								},
								Description: `The library that your query engine will use for reading and writing data in your lake.`,
							},
							"s3_bucket_name": schema.StringAttribute{
								Computed: true,
							},
							"s3_bucket_path": schema.StringAttribute{
								Computed: true,
							},
							"s3_bucket_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.`,
							},
							"s3_endpoint": schema.StringAttribute{
								Computed: true,
							},
							"s3_path_format": schema.StringAttribute{
								Computed: true,
							},
							"secret_access_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_scylla": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"address": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"scylla",
									),
								},
							},
							"keyspace": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication": schema.Int64Attribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_sftp_json": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sftp-json",
									),
								},
							},
							"destination_path": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_snowflake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_snowflake_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"destination_snowflake_authorization_method_key_pair_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Key Pair Authentication",
													),
												},
											},
											"private_key": schema.StringAttribute{
												Computed: true,
											},
											"private_key_password": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"destination_snowflake_authorization_method_username_and_password": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Username and Password",
													),
												},
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"snowflake",
									),
								},
							},
							"file_buffer_count": schema.Int64Attribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"loading_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"destination_snowflake_data_staging_method_select_another_option": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `Select another option`,
									},
									"destination_snowflake_data_staging_method_recommended_internal_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Internal Staging",
													),
												},
											},
										},
										Description: `Recommended for large production workloads for better speed and scalability.`,
									},
									"destination_snowflake_data_staging_method_aws_s3_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_key_id": schema.StringAttribute{
												Computed: true,
											},
											"encryption": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"destination_snowflake_data_staging_method_aws_s3_staging_encryption_no_encryption": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"encryption_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"none",
																	),
																},
															},
														},
														Description: `Staging data will be stored in plaintext.`,
													},
													"destination_snowflake_data_staging_method_aws_s3_staging_encryption_aes_cbc_envelope_encryption": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"encryption_type": schema.StringAttribute{
																Computed: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"aes_cbc_envelope",
																	),
																},
															},
															"key_encrypting_key": schema.StringAttribute{
																Computed: true,
															},
														},
														Description: `Staging data will be encrypted using AES-CBC envelope encryption.`,
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
											"file_name_pattern": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"S3 Staging",
													),
												},
											},
											"purge_staging_data": schema.BoolAttribute{
												Computed: true,
											},
											"s3_bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"s3_bucket_region": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"us-east-1",
														"us-east-2",
														"us-west-1",
														"us-west-2",
														"af-south-1",
														"ap-east-1",
														"ap-south-1",
														"ap-northeast-1",
														"ap-northeast-2",
														"ap-northeast-3",
														"ap-southeast-1",
														"ap-southeast-2",
														"ca-central-1",
														"cn-north-1",
														"cn-northwest-1",
														"eu-central-1",
														"eu-west-1",
														"eu-west-2",
														"eu-west-3",
														"eu-south-1",
														"eu-north-1",
														"sa-east-1",
														"me-south-1",
													),
												},
												Description: `Enter the region where your S3 bucket resides`,
											},
											"secret_access_key": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Recommended for large production workloads for better speed and scalability.`,
									},
									"destination_snowflake_data_staging_method_google_cloud_storage_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"bucket_name": schema.StringAttribute{
												Computed: true,
											},
											"credentials_json": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"GCS Staging",
													),
												},
											},
											"project_id": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Recommended for large production workloads for better speed and scalability.`,
									},
									"destination_snowflake_data_staging_method_azure_blob_storage_staging": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"azure_blob_storage_account_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_container_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_endpoint_domain_name": schema.StringAttribute{
												Computed: true,
											},
											"azure_blob_storage_sas_token": schema.StringAttribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Azure Blob Staging",
													),
												},
											},
										},
										Description: `Recommended for large production workloads for better speed and scalability.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"role": schema.StringAttribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
							"warehouse": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
					"destination_typesense": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"batch_size": schema.StringAttribute{
								Computed: true,
							},
							"destination_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"typesense",
									),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.StringAttribute{
								Computed: true,
							},
							"protocol": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the destination.`,
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"destination_id": schema.StringAttribute{
				Computed: true,
			},
			"destination_type": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"workspace_id": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

func (r *DestinationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *DestinationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *DestinationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToCreateSDKType()
	res, err := r.client.Destinations.CreateDestination(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.DestinationResponse == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromCreateResponse(res.DestinationResponse)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *DestinationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; we rely entirely on CREATE API request response

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *DestinationResourceModel
	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DestinationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *DestinationResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	destinationID := data.DestinationID.ValueString()
	request := operations.DeleteDestinationRequest{
		DestinationID: destinationID,
	}
	res, err := r.client.Destinations.DeleteDestination(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *DestinationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
