// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"airbyte/internal/sdk"
	"context"
	"fmt"

	"airbyte/internal/sdk/pkg/models/operations"
	"airbyte/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SourceResource{}
var _ resource.ResourceWithImportState = &SourceResource{}

func NewSourceResource() resource.Resource {
	return &SourceResource{}
}

// SourceResource defines the resource implementation.
type SourceResource struct {
	client *sdk.SDK
}

// SourceResourceModel describes the resource data model.
type SourceResourceModel struct {
	Configuration SourceConfiguration `tfsdk:"configuration"`
	Name          types.String        `tfsdk:"name"`
	SecretID      types.String        `tfsdk:"secret_id"`
	SourceID      types.String        `tfsdk:"source_id"`
	SourceType    types.String        `tfsdk:"source_type"`
	WorkspaceID   types.String        `tfsdk:"workspace_id"`
}

func (r *SourceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_source"
}

func (r *SourceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Source Resource",

		Attributes: map[string]schema.Attribute{
			"configuration": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"source_pokeapi": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"pokemon_name": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pokeapi",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_airtable": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_airtable_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									"source_airtable_authentication_personal_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_key": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_key",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"airtable",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_alloydb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_alloydb_replication_method_standard": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.`,
									},
									"source_alloydb_replication_method_logical_replication_cdc_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"initial_waiting_seconds": schema.Int64Attribute{
												Computed: true,
											},
											"lsn_commit_behaviour": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"While reading Data",
														"After loading Data in the destination",
													),
												},
												Description: `Determines when Airbtye should flush the LSN of processed WAL logs in the source database. ` + "`" + `After loading Data in the destination` + "`" + ` is default. If ` + "`" + `While reading Data` + "`" + ` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.`,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CDC",
													),
												},
											},
											"plugin": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"pgoutput",
													),
												},
												Description: `A logical decoding plugin installed on the PostgreSQL server.`,
											},
											"publication": schema.StringAttribute{
												Computed: true,
											},
											"replication_slot": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"alloydb",
									),
								},
							},
							"ssl_mode": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_alloydb_ssl_modes_disable": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"disable",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Disables encryption of communication between Airbyte and source database.`,
									},
									"source_alloydb_ssl_modes_allow": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"allow",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Enables encryption only when required by the source database.`,
									},
									"source_alloydb_ssl_modes_prefer": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"prefer",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Allows unencrypted connection only if the source database does not support encryption.`,
									},
									"source_alloydb_ssl_modes_require": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"require",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Always require encryption. If the source database server does not support encryption, connection will fail.`,
									},
									"source_alloydb_ssl_modes_verify_ca": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-ca",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Always require encryption and verifies that the source database server has a valid SSL certificate.`,
									},
									"source_alloydb_ssl_modes_verify_full": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-full",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `This is the most secure mode. Always require encryption and verifies the identity of the source database server.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_alloydb_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_alloydb_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_alloydb_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_amazon_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"oauth2.0",
									),
								},
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"look_back_window": schema.Int64Attribute{
								Computed: true,
							},
							"profiles": schema.ListAttribute{
								Computed:    true,
								ElementType: types.Int64Type,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NA",
										"EU",
										"FE",
									),
								},
								Description: `Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details.`,
							},
							"report_record_types": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"amazon-ads",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"state_filter": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_amazon_seller_partner": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"app_id": schema.StringAttribute{
								Computed: true,
							},
							"auth_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"oauth2.0",
									),
								},
							},
							"aws_access_key": schema.StringAttribute{
								Computed: true,
							},
							"aws_environment": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRODUCTION",
										"SANDBOX",
									),
								},
								Description: `An enumeration.`,
							},
							"aws_secret_key": schema.StringAttribute{
								Computed: true,
							},
							"lwa_app_id": schema.StringAttribute{
								Computed: true,
							},
							"lwa_client_secret": schema.StringAttribute{
								Computed: true,
							},
							"max_wait_seconds": schema.Int64Attribute{
								Computed: true,
							},
							"period_in_days": schema.Int64Attribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"AE",
										"AU",
										"BE",
										"BR",
										"CA",
										"DE",
										"EG",
										"ES",
										"FR",
										"GB",
										"IN",
										"IT",
										"JP",
										"MX",
										"NL",
										"PL",
										"SA",
										"SE",
										"SG",
										"TR",
										"UK",
										"US",
									),
								},
								Description: `An enumeration.`,
							},
							"replication_end_date": schema.StringAttribute{
								Computed: true,
							},
							"replication_start_date": schema.StringAttribute{
								Computed: true,
							},
							"report_options": schema.StringAttribute{
								Computed: true,
							},
							"role_arn": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"amazon-seller-partner",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_amazon_sqs": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"attributes_to_return": schema.StringAttribute{
								Computed: true,
							},
							"delete_messages": schema.BoolAttribute{
								Computed: true,
							},
							"max_batch_size": schema.Int64Attribute{
								Computed: true,
							},
							"max_wait_time": schema.Int64Attribute{
								Computed: true,
							},
							"queue_url": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `AWS Region of the SQS Queue`,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"amazon-sqs",
									),
								},
							},
							"visibility_timeout": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_amplitude": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"data_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Standard Server",
										"EU Residency Server",
									),
								},
								Description: `Amplitude data region server`,
							},
							"request_time_range": schema.Int64Attribute{
								Computed: true,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"amplitude",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_apify_dataset": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"clean": schema.BoolAttribute{
								Computed: true,
							},
							"dataset_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"apify-dataset",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_asana": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_asana_authentication_mechanism_authenticate_with_personal_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"PAT Credentials",
													),
												},
												Description: `PAT Credentials`,
											},
											"personal_access_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Github`,
									},
									"source_asana_authentication_mechanism_authenticate_via_asana_oauth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth Credentials",
													),
												},
												Description: `OAuth Credentials`,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Github`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"asana",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_auth0": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"base_url": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_auth0_authentication_method_o_auth2_confidential_application": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"audience": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2_confidential_application",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_auth0_authentication_method_o_auth2_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2_access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"auth0",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_aws_cloudtrail": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"aws_key_id": schema.StringAttribute{
								Computed: true,
							},
							"aws_region_name": schema.StringAttribute{
								Computed: true,
							},
							"aws_secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"aws-cloudtrail",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_azure_blob_storage": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"azure_blob_storage_account_key": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_account_name": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_blobs_prefix": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_container_name": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_endpoint": schema.StringAttribute{
								Computed: true,
							},
							"azure_blob_storage_schema_inference_limit": schema.Int64Attribute{
								Computed: true,
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_azure_blob_storage_input_format_json_lines_newline_delimited_json": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"format_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"JSONL",
													),
												},
											},
										},
										Description: `Input data format`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"azure-blob-storage",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_azure_table": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"azure-table",
									),
								},
							},
							"storage_access_key": schema.StringAttribute{
								Computed: true,
							},
							"storage_account_name": schema.StringAttribute{
								Computed: true,
							},
							"storage_endpoint_suffix": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_bamboo_hr": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"custom_reports_fields": schema.StringAttribute{
								Computed: true,
							},
							"custom_reports_include_default_fields": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bamboo-hr",
									),
								},
							},
							"subdomain": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_bigcommerce": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bigcommerce",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"store_hash": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_bigquery": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"dataset_id": schema.StringAttribute{
								Computed: true,
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bigquery",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_bing_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_method": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"oauth2.0",
									),
								},
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"developer_token": schema.StringAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"reports_start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bing-ads",
									),
								},
							},
							"tenant_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_braintree": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"environment": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Development",
										"Sandbox",
										"Qa",
										"Production",
									),
								},
								Description: `Environment specifies where the data will come from.`,
							},
							"merchant_id": schema.StringAttribute{
								Computed: true,
							},
							"private_key": schema.StringAttribute{
								Computed: true,
							},
							"public_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"braintree",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_braze": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"braze",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_chargebee": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"product_catalog": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"1.0",
										"2.0",
									),
								},
								Description: `Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under ` + "`" + `API Version` + "`" + ` section.`,
							},
							"site": schema.StringAttribute{
								Computed: true,
							},
							"site_api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"chargebee",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_chartmogul": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"interval": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"day",
										"week",
										"month",
										"quarter",
									),
								},
								Description: `Some APIs such as <a href="https://dev.chartmogul.com/reference/endpoint-overview-metrics-api">Metrics</a> require intervals to cluster data.`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"chartmogul",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_clickhouse": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"clickhouse",
									),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_clickhouse_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_clickhouse_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_clickhouse_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_clickup_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"folder_id": schema.StringAttribute{
								Computed: true,
							},
							"include_closed_tasks": schema.BoolAttribute{
								Computed: true,
							},
							"list_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"clickup-api",
									),
								},
							},
							"space_id": schema.StringAttribute{
								Computed: true,
							},
							"team_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_close_com": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"close-com",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_coda": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"coda",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_coin_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
							},
							"environment": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sandbox",
										"production",
									),
								},
								Description: `The environment to use. Either sandbox or production. `,
							},
							"limit": schema.Int64Attribute{
								Computed: true,
							},
							"period": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"coin-api",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"symbol_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_coinmarketcap": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"data_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"latest",
										"historical",
									),
								},
								Description: `/latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>.`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"coinmarketcap",
									),
								},
							},
							"symbols": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_configcat": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"password": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"configcat",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_confluence": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"domain_name": schema.StringAttribute{
								Computed: true,
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"confluence",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_datascope": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"datascope",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_delighted": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"since": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"delighted",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_dixa": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"batch_size": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"dixa",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_dockerhub": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"docker_username": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"dockerhub",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_dremio": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"base_url": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"dremio",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_dynamodb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key_id": schema.StringAttribute{
								Computed: true,
							},
							"endpoint": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"us-east-1",
										"us-east-2",
										"us-west-1",
										"us-west-2",
										"af-south-1",
										"ap-east-1",
										"ap-south-1",
										"ap-northeast-1",
										"ap-northeast-2",
										"ap-northeast-3",
										"ap-southeast-1",
										"ap-southeast-2",
										"ca-central-1",
										"cn-north-1",
										"cn-northwest-1",
										"eu-central-1",
										"eu-north-1",
										"eu-south-1",
										"eu-west-1",
										"eu-west-2",
										"eu-west-3",
										"sa-east-1",
										"me-south-1",
										"us-gov-east-1",
										"us-gov-west-1",
									),
								},
								Description: `The region of the Dynamodb database`,
							},
							"reserved_attribute_names": schema.StringAttribute{
								Computed: true,
							},
							"secret_access_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"dynamodb",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_e2e_test_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"max_messages": schema.Int64Attribute{
								Computed: true,
							},
							"message_interval_ms": schema.Int64Attribute{
								Computed: true,
							},
							"mock_catalog": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_e2e_test_cloud_mock_catalog_single_schema": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"stream_duplication": schema.Int64Attribute{
												Computed: true,
											},
											"stream_name": schema.StringAttribute{
												Computed: true,
											},
											"stream_schema": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SINGLE_STREAM",
													),
												},
											},
										},
										Description: `A catalog with one or multiple streams that share the same schema.`,
									},
									"source_e2e_test_cloud_mock_catalog_multi_schema": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"stream_schemas": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"MULTI_STREAM",
													),
												},
											},
										},
										Description: `A catalog with multiple data streams, each with a different schema.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"seed": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"e2e-test-cloud",
									),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"CONTINUOUS_FEED",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_emailoctopus": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"emailoctopus",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_exchange_rates": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"base": schema.StringAttribute{
								Computed: true,
							},
							"ignore_weekends": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"exchange-rates",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_facebook_marketing": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"account_id": schema.StringAttribute{
								Computed: true,
							},
							"action_breakdowns_allow_empty": schema.BoolAttribute{
								Computed: true,
							},
							"custom_insights": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"action_breakdowns": schema.ListAttribute{
											Computed:    true,
											Optional:    true,
											ElementType: types.StringType,
										},
										"breakdowns": schema.ListAttribute{
											Computed:    true,
											Optional:    true,
											ElementType: types.StringType,
										},
										"end_date": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"fields": schema.ListAttribute{
											Computed:    true,
											Optional:    true,
											ElementType: types.StringType,
										},
										"insights_lookback_window": schema.Int64Attribute{
											Computed: true,
											Optional: true,
										},
										"level": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"ad",
													"adset",
													"campaign",
													"account",
												),
											},
											Description: `Chosen level for API`,
										},
										"name": schema.StringAttribute{
											Required: true,
										},
										"start_date": schema.StringAttribute{
											Computed: true,
											Optional: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"time_increment": schema.Int64Attribute{
											Computed: true,
											Optional: true,
										},
									},
								},
							},
							"end_date": schema.StringAttribute{
								Computed: true,
							},
							"fetch_thumbnail_images": schema.BoolAttribute{
								Computed: true,
							},
							"include_deleted": schema.BoolAttribute{
								Computed: true,
							},
							"insights_lookback_window": schema.Int64Attribute{
								Computed: true,
							},
							"max_batch_size": schema.Int64Attribute{
								Computed: true,
							},
							"page_size": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"facebook-marketing",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_facebook_pages": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"page_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"facebook-pages",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_faker": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"count": schema.Int64Attribute{
								Computed: true,
							},
							"parallelism": schema.Int64Attribute{
								Computed: true,
							},
							"records_per_slice": schema.Int64Attribute{
								Computed: true,
							},
							"records_per_sync": schema.Int64Attribute{
								Computed: true,
							},
							"seed": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"faker",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_fauna": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"collection": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"deletions": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"source_fauna_collection_deletion_mode_disabled": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"deletion_mode": schema.StringAttribute{
														Computed: true,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"ignore",
															),
														},
													},
												},
												Description: `<b>This only applies to incremental syncs.</b> <br> Enabling deletion mode informs your destination of deleted documents.<br> Disabled - Leave this feature disabled, and ignore deleted documents.<br> Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.`,
											},
											"source_fauna_collection_deletion_mode_enabled": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"column": schema.StringAttribute{
														Computed: true,
													},
													"deletion_mode": schema.StringAttribute{
														Computed: true,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"deleted_field",
															),
														},
													},
												},
												Description: `<b>This only applies to incremental syncs.</b> <br> Enabling deletion mode informs your destination of deleted documents.<br> Disabled - Leave this feature disabled, and ignore deleted documents.<br> Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.`,
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
									"page_size": schema.Int64Attribute{
										Computed: true,
									},
								},
								Description: `Settings for the Fauna Collection.`,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"scheme": schema.StringAttribute{
								Computed: true,
							},
							"secret": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"fauna",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_file_secure": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"dataset_name": schema.StringAttribute{
								Computed: true,
							},
							"format": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"csv",
										"json",
										"jsonl",
										"excel",
										"excel_binary",
										"feather",
										"parquet",
										"yaml",
									),
								},
								Description: `The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).`,
							},
							"provider": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_file_secure_storage_provider_https_public_web": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"HTTPS",
													),
												},
											},
											"user_agent": schema.BoolAttribute{
												Computed: true,
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_gcs_google_cloud_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"service_account_json": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"GCS",
													),
												},
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_s3_amazon_web_services": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"aws_access_key_id": schema.StringAttribute{
												Computed: true,
											},
											"aws_secret_access_key": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"S3",
													),
												},
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_az_blob_azure_blob_storage": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"sas_token": schema.StringAttribute{
												Computed: true,
											},
											"shared_key": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"AzBlob",
													),
												},
											},
											"storage_account": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_ssh_secure_shell": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"port": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH",
													),
												},
											},
											"user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_scp_secure_copy_protocol": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"port": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SCP",
													),
												},
											},
											"user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
									"source_file_secure_storage_provider_sftp_secure_file_transfer_protocol": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"port": schema.StringAttribute{
												Computed: true,
											},
											"storage": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SFTP",
													),
												},
											},
											"user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The storage Provider or Location of the file(s) which should be replicated.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"reader_options": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"file-secure",
									),
								},
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_firebolt": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account": schema.StringAttribute{
								Computed: true,
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"engine": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"firebolt",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_freshcaller": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"requests_per_minute": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"freshcaller",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
								Description: `Parsed as JSON.`,
							},
							"sync_lag_minutes": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_freshdesk": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"requests_per_minute": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"freshdesk",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_freshsales": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"domain_name": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"freshsales",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_gcs": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"gcs_bucket": schema.StringAttribute{
								Computed: true,
							},
							"gcs_path": schema.StringAttribute{
								Computed: true,
							},
							"service_account": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gcs",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_getlago": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"getlago",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_github": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"branch": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_github_authentication_o_auth": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth Credentials",
													),
												},
											},
										},
										Description: `Choose how to authenticate to GitHub`,
									},
									"source_github_authentication_personal_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"PAT Credentials",
													),
												},
											},
											"personal_access_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to GitHub`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"page_size_for_large_streams": schema.Int64Attribute{
								Computed: true,
							},
							"repository": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"github",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_gitlab": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_url": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_gitlab_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									"source_gitlab_authorization_method_private_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"groups": schema.StringAttribute{
								Computed: true,
							},
							"projects": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gitlab",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_glassfrog": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"glassfrog",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_gnews": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"country": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"au",
										"br",
										"ca",
										"cn",
										"eg",
										"fr",
										"de",
										"gr",
										"hk",
										"in",
										"ie",
										"il",
										"it",
										"jp",
										"nl",
										"no",
										"pk",
										"pe",
										"ph",
										"pt",
										"ro",
										"ru",
										"sg",
										"es",
										"se",
										"ch",
										"tw",
										"ua",
										"gb",
										"us",
									),
								},
								Description: `This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter.`,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
							},
							"in": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"language": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ar",
										"zh",
										"nl",
										"en",
										"fr",
										"de",
										"el",
										"he",
										"hi",
										"it",
										"ja",
										"ml",
										"mr",
										"no",
										"pt",
										"ro",
										"ru",
										"es",
										"sv",
										"ta",
										"te",
										"uk",
									),
								},
							},
							"nullable": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"query": schema.StringAttribute{
								Computed: true,
							},
							"sortby": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"publishedAt",
										"relevance",
									),
								},
								Description: `This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible: - publishedAt = sort by publication date, the articles with the most recent publication date are returned first - relevance = sort by best match to keywords, the articles with the best match are returned first`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gnews",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"top_headlines_query": schema.StringAttribute{
								Computed: true,
							},
							"top_headlines_topic": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"breaking-news",
										"world",
										"nation",
										"business",
										"technology",
										"entertainment",
										"sports",
										"science",
										"health",
									),
								},
								Description: `This parameter allows you to change the category for the request.`,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"conversion_window_days": schema.Int64Attribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"access_token": schema.StringAttribute{
										Computed: true,
									},
									"client_id": schema.StringAttribute{
										Computed: true,
									},
									"client_secret": schema.StringAttribute{
										Computed: true,
									},
									"developer_token": schema.StringAttribute{
										Computed: true,
									},
									"refresh_token": schema.StringAttribute{
										Computed: true,
									},
								},
							},
							"custom_queries": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"query": schema.StringAttribute{
											Required: true,
										},
										"table_name": schema.StringAttribute{
											Required: true,
										},
									},
								},
							},
							"customer_id": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"login_customer_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-ads",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_analytics_data_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_google_analytics_data_api_credentials_authenticate_via_google_oauth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for the service`,
									},
									"source_google_analytics_data_api_credentials_service_account_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Service",
													),
												},
											},
											"credentials_json": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for the service`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"custom_reports": schema.StringAttribute{
								Computed: true,
							},
							"date_ranges_start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"property_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-analytics-data-api",
									),
								},
							},
							"window_in_days": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_analytics_v4": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_google_analytics_v4_credentials_authenticate_via_google_oauth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for the service`,
									},
									"source_google_analytics_v4_credentials_service_account_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Service",
													),
												},
											},
											"credentials_json": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for the service`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"custom_reports": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-analytics-v4",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"view_id": schema.StringAttribute{
								Computed: true,
							},
							"window_in_days": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_directory": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-directory",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_search_console": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"authorization": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_google_search_console_authentication_type_o_auth": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_google_search_console_authentication_type_service_account_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Service",
													),
												},
											},
											"email": schema.StringAttribute{
												Computed: true,
											},
											"service_account_info": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"custom_reports": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"site_urls": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-search-console",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_sheets": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_google_sheets_authentication_authenticate_via_google_o_auth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for connecting to the Google Sheets API`,
									},
									"source_google_sheets_authentication_service_account_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Service",
													),
												},
											},
											"service_account_info": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Credentials for connecting to the Google Sheets API`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"row_batch_size": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-sheets",
									),
								},
							},
							"spreadsheet_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_webfonts": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"alt": schema.StringAttribute{
								Computed: true,
							},
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"pretty_print": schema.StringAttribute{
								Computed: true,
							},
							"sort": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-webfonts",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_google_workspace_admin_reports": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials_json": schema.StringAttribute{
								Computed: true,
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"lookback": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"google-workspace-admin-reports",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_greenhouse": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"greenhouse",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_gridly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"grid_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gridly",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_harvest": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_id": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_harvest_authentication_mechanism_authenticate_via_harvest_o_auth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Choose how to authenticate to Harvest.`,
									},
									"source_harvest_authentication_mechanism_authenticate_with_personal_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Token",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Choose how to authenticate to Harvest.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"replication_end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"replication_start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"harvest",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_hubplanner": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"hubplanner",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_hubspot": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_hubspot_authentication_o_auth": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth Credentials",
													),
												},
												Description: `Name of the credentials`,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to HubSpot.`,
									},
									"source_hubspot_authentication_private_app": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Private App Credentials",
													),
												},
												Description: `Name of the credentials set`,
											},
										},
										Description: `Choose how to authenticate to HubSpot.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"hubspot",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_insightly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"insightly",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_instagram": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"instagram",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_instatus": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"instatus",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_intercom": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"intercom",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_ip2whois": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ip2whois",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_iterable": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"iterable",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_jira": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"enable_experimental_streams": schema.BoolAttribute{
								Computed: true,
							},
							"expand_issue_changelog": schema.BoolAttribute{
								Computed: true,
							},
							"projects": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"render_fields": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"jira",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_k6_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"k6-cloud",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_klarna": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"password": schema.StringAttribute{
								Computed: true,
							},
							"playground": schema.BoolAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"eu",
										"us",
										"oc",
									),
								},
								Description: `Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"klarna",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_klaviyo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"klaviyo",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_kustomer_singer": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"kustomer-singer",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_launchdarkly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"launchdarkly",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_lemlist": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"lemlist",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_linkedin_ads": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.Int64Type,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_linkedin_ads_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oAuth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_linkedin_ads_authentication_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"linkedin-ads",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_linkedin_pages": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_linkedin_pages_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oAuth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_linkedin_pages_authentication_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"org_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"linkedin-pages",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_linnworks": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"application_id": schema.StringAttribute{
								Computed: true,
							},
							"application_secret": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"linnworks",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_lokalise": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"lokalise",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mailchimp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"campaign_id": schema.StringAttribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mailchimp_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_mailchimp_authentication_api_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"apikey": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"apikey",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mailchimp",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mailgun": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"domain_region": schema.StringAttribute{
								Computed: true,
							},
							"private_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mailgun",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mailjet_sms": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"end_date": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mailjet-sms",
									),
								},
							},
							"start_date": schema.Int64Attribute{
								Computed: true,
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_marketo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"domain_url": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"marketo",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_metabase": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"instance_api_url": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"session_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"metabase",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_microsoft_teams": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_microsoft_teams_authentication_mechanism_authenticate_via_microsoft_o_auth_2_0_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"tenant_id": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Microsoft`,
									},
									"source_microsoft_teams_authentication_mechanism_authenticate_via_microsoft": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Token",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"tenant_id": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Microsoft`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"period": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"microsoft-teams",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mixpanel": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"attribution_window": schema.Int64Attribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mixpanel_authentication_wildcard_service_account": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Service Account",
													),
												},
											},
											"secret": schema.StringAttribute{
												Computed: true,
											},
											"username": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Mixpanel`,
									},
									"source_mixpanel_authentication_wildcard_project_secret": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_secret": schema.StringAttribute{
												Computed: true,
											},
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Project Secret",
													),
												},
											},
										},
										Description: `Choose how to authenticate to Mixpanel`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"date_window_size": schema.Int64Attribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"project_id": schema.Int64Attribute{
								Computed: true,
							},
							"project_timezone": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"US",
										"EU",
									),
								},
								Description: `The region of mixpanel domain instance either US or EU.`,
							},
							"select_properties_by_default": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mixpanel",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_monday": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_monday_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"subdomain": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_monday_authorization_method_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"monday",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mongodb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_source": schema.StringAttribute{
								Computed: true,
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"instance_type": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mongodb_mongo_db_instance_type_standalone_mongo_db_instance": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"standalone",
													),
												},
											},
											"port": schema.Int64Attribute{
												Computed: true,
											},
										},
										Description: `The MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
									"source_mongodb_mongo_db_instance_type_replica_set": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"replica",
													),
												},
											},
											"replica_set": schema.StringAttribute{
												Computed: true,
											},
											"server_addresses": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
									"source_mongodb_mongo_db_instance_type_mongo_db_atlas": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"cluster_url": schema.StringAttribute{
												Computed: true,
											},
											"instance": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"atlas",
													),
												},
											},
										},
										Description: `The MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mongodb",
									),
								},
							},
							"user": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mssql": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mssql_replication_method_standard": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"STANDARD",
													),
												},
											},
										},
										Description: `Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.`,
									},
									"source_mssql_replication_method_logical_replication_cdc_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"data_to_sync": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Existing and New",
														"New Changes Only",
													),
												},
												Description: `What data should be synced under the CDC. "Existing and New" will read existing data as a snapshot, and sync new changes through CDC. "New Changes Only" will skip the initial snapshot, and only sync new changes through CDC.`,
											},
											"initial_waiting_seconds": schema.Int64Attribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CDC",
													),
												},
											},
											"snapshot_isolation": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Snapshot",
														"Read Committed",
													),
												},
												Description: `Existing data in the database are synced through an initial snapshot. This parameter controls the isolation level that will be used during the initial snapshotting. If you choose the "Snapshot" level, you must enable the <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">snapshot isolation mode</a> on the database.`,
											},
										},
										Description: `CDC uses {TBC} to detect inserts, updates, and deletes. This needs to be configured on the source database itself.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mssql",
									),
								},
							},
							"ssl_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mssql_ssl_method_encrypted_trust_server_certificate_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssl_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"encrypted_trust_server_certificate",
													),
												},
											},
										},
										Description: `Use the certificate provided by the server without verification. (For testing purposes only!)`,
									},
									"source_mssql_ssl_method_encrypted_verify_certificate_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"host_name_in_certificate": schema.StringAttribute{
												Computed: true,
											},
											"ssl_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"encrypted_verify_certificate",
													),
												},
											},
										},
										Description: `Verify and use the certificate provided by the server.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mssql_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_mssql_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_mssql_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_my_hours": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"email": schema.StringAttribute{
								Computed: true,
							},
							"logs_batch_size": schema.Int64Attribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"my-hours",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_mysql": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mysql_replication_method_standard": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"STANDARD",
													),
												},
											},
										},
										Description: `Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.`,
									},
									"source_mysql_replication_method_logical_replication_cdc_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"initial_waiting_seconds": schema.Int64Attribute{
												Computed: true,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CDC",
													),
												},
											},
											"server_time_zone": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"mysql",
									),
								},
							},
							"ssl_mode": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mysql_ssl_modes_preferred": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"preferred",
													),
												},
											},
										},
										Description: `Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.`,
									},
									"source_mysql_ssl_modes_required": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"required",
													),
												},
											},
										},
										Description: `Always connect with SSL. If the MySQL server doesn’t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.`,
									},
									"source_mysql_ssl_modes_verify_ca": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify_ca",
													),
												},
											},
										},
										Description: `Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.`,
									},
									"source_mysql_ssl_modes_verify_identity": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify_identity",
													),
												},
											},
										},
										Description: `Always connect with SSL. Verify both CA and Hostname.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_mysql_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_mysql_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_mysql_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_netsuite": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"consumer_key": schema.StringAttribute{
								Computed: true,
							},
							"consumer_secret": schema.StringAttribute{
								Computed: true,
							},
							"object_types": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"realm": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"netsuite",
									),
								},
							},
							"start_datetime": schema.StringAttribute{
								Computed: true,
							},
							"token_key": schema.StringAttribute{
								Computed: true,
							},
							"token_secret": schema.StringAttribute{
								Computed: true,
							},
							"window_in_days": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_notion": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_notion_authenticate_using_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Pick an authentication method.`,
									},
									"source_notion_authenticate_using_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"token",
													),
												},
											},
											"token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Pick an authentication method.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"notion",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_nytimes": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"period": schema.Int64Attribute{
								Computed: true,
								Validators: []validator.Int64{
									int64validator.OneOf(
										[]int64{
											1,
											7,
											30,
										}...,
									),
								},
								Description: `Period of time (in days)`,
							},
							"share_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"facebook",
									),
								},
								Description: `Share Type`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"nytimes",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_okta": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_okta_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_okta_authorization_method_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"okta",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_omnisend": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"omnisend",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_onesignal": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"applications": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"app_api_key": schema.StringAttribute{
											Required: true,
										},
										"app_id": schema.StringAttribute{
											Required: true,
										},
										"app_name": schema.StringAttribute{
											Computed: true,
											Optional: true,
										},
									},
								},
							},
							"outcome_names": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"onesignal",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"user_auth_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_openweather": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"appid": schema.StringAttribute{
								Computed: true,
							},
							"lang": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"af",
										"al",
										"ar",
										"az",
										"bg",
										"ca",
										"cz",
										"da",
										"de",
										"el",
										"en",
										"eu",
										"fa",
										"fi",
										"fr",
										"gl",
										"he",
										"hi",
										"hr",
										"hu",
										"id",
										"it",
										"ja",
										"kr",
										"la",
										"lt",
										"mk",
										"no",
										"nl",
										"pl",
										"pt",
										"pt_br",
										"ro",
										"ru",
										"sv",
										"se",
										"sk",
										"sl",
										"sp",
										"es",
										"sr",
										"th",
										"tr",
										"ua",
										"uk",
										"vi",
										"zh_cn",
										"zh_tw",
										"zu",
									),
								},
								Description: `You can use lang parameter to get the output in your language. The contents of the description field will be translated. See <a href="https://openweathermap.org/api/one-call-api#multi">here</a> for the list of supported languages.`,
							},
							"lat": schema.StringAttribute{
								Computed: true,
							},
							"lon": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"openweather",
									),
								},
							},
							"units": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"standard",
										"metric",
										"imperial",
									),
								},
								Description: `Units of measurement. standard, metric and imperial units are available. If you do not use the units parameter, standard units will be applied by default.`,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_oracle": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"connection_data": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_oracle_connect_by_service_name": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"connection_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"service_name",
													),
												},
											},
											"service_name": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Use service name`,
									},
									"source_oracle_connect_by_system_id_sid_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"connection_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"sid",
													),
												},
											},
											"sid": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Use SID (Oracle System Identifier)`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"encryption": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_oracle_encryption_native_network_encryption_nne_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"encryption_algorithm": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"AES256",
														"RC4_56",
														"3DES168",
													),
												},
												Description: `This parameter defines what encryption algorithm is used.`,
											},
											"encryption_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"client_nne",
													),
												},
											},
										},
										Description: `The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.`,
									},
									"source_oracle_encryption_tls_encrypted_verify_certificate_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"encryption_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"encrypted_verify_certificate",
													),
												},
											},
											"ssl_certificate": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Verify and use the certificate provided by the server.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"oracle",
									),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_oracle_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_oracle_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_oracle_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_orb": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"lookback_window_days": schema.Int64Attribute{
								Computed: true,
							},
							"numeric_event_properties_keys": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"plan_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"orb",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"string_event_properties_keys": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"subscription_usage_grouping_key": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_orbit": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"orbit",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"workspace": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_outreach": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"redirect_uri": schema.StringAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"outreach",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_paypal_transaction": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"is_sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"paypal-transaction",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_paystack": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"lookback_window_days": schema.Int64Attribute{
								Computed: true,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"paystack",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pendo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pendo",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_persistiq": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"persistiq",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pexels_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"color": schema.StringAttribute{
								Computed: true,
							},
							"locale": schema.StringAttribute{
								Computed: true,
							},
							"orientation": schema.StringAttribute{
								Computed: true,
							},
							"query": schema.StringAttribute{
								Computed: true,
							},
							"size": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pexels-api",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pinterest": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_pinterest_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_pinterest_authorization_method_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pinterest",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"status": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pipedrive": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"authorization": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"api_token": schema.StringAttribute{
										Computed: true,
									},
									"auth_type": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"Token",
											),
										},
									},
								},
							},
							"replication_start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pipedrive",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pocket": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"consumer_key": schema.StringAttribute{
								Computed: true,
							},
							"content_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"article",
										"video",
										"image",
									),
								},
								Description: `Select the content type of the items to retrieve.`,
							},
							"detail_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"simple",
										"complete",
									),
								},
								Description: `Select the granularity of the information about each item.`,
							},
							"domain": schema.StringAttribute{
								Computed: true,
							},
							"favorite": schema.BoolAttribute{
								Computed: true,
							},
							"search": schema.StringAttribute{
								Computed: true,
							},
							"since": schema.StringAttribute{
								Computed: true,
							},
							"sort": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"newest",
										"oldest",
										"title",
										"site",
									),
								},
								Description: `Sort retrieved items by the given criteria.`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pocket",
									),
								},
							},
							"state": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"unread",
										"archive",
										"all",
									),
								},
								Description: `Select the state of the items to retrieve.`,
							},
							"tag": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_polygon_stock_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"adjusted": schema.StringAttribute{
								Computed: true,
							},
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"limit": schema.Int64Attribute{
								Computed: true,
							},
							"multiplier": schema.Int64Attribute{
								Computed: true,
							},
							"sort": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"polygon-stock-api",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"stocks_ticker": schema.StringAttribute{
								Computed: true,
							},
							"timespan": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_postgres": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"replication_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_postgres_replication_method_standard": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Standard",
													),
												},
											},
										},
										Description: `Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.`,
									},
									"source_postgres_replication_method_logical_replication_cdc_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"initial_waiting_seconds": schema.Int64Attribute{
												Computed: true,
											},
											"lsn_commit_behaviour": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"While reading Data",
														"After loading Data in the destination",
													),
												},
												Description: `Determines when Airbtye should flush the LSN of processed WAL logs in the source database. ` + "`" + `After loading Data in the destination` + "`" + ` is default. If ` + "`" + `While reading Data` + "`" + ` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.`,
											},
											"method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"CDC",
													),
												},
											},
											"plugin": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"pgoutput",
													),
												},
												Description: `A logical decoding plugin installed on the PostgreSQL server.`,
											},
											"publication": schema.StringAttribute{
												Computed: true,
											},
											"replication_slot": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"postgres",
									),
								},
							},
							"ssl_mode": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_postgres_ssl_modes_disable": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"disable",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Disables encryption of communication between Airbyte and source database.`,
									},
									"source_postgres_ssl_modes_allow": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"allow",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Enables encryption only when required by the source database.`,
									},
									"source_postgres_ssl_modes_prefer": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"prefer",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Allows unencrypted connection only if the source database does not support encryption.`,
									},
									"source_postgres_ssl_modes_require": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"require",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Always require encryption. If the source database server does not support encryption, connection will fail.`,
									},
									"source_postgres_ssl_modes_verify_ca": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-ca",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Always require encryption and verifies that the source database server has a valid SSL certificate.`,
									},
									"source_postgres_ssl_modes_verify_full": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_certificate": schema.StringAttribute{
												Computed: true,
											},
											"client_key": schema.StringAttribute{
												Computed: true,
											},
											"client_key_password": schema.StringAttribute{
												Computed: true,
											},
											"mode": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"verify-full",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `This is the most secure mode. Always require encryption and verifies the identity of the source database server.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"tunnel_method": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_postgres_ssh_tunnel_method_no_tunnel": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"NO_TUNNEL",
													),
												},
												Description: `No ssh tunnel needed to connect to database`,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_postgres_ssh_tunnel_method_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"ssh_key": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and ssh key`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
									"source_postgres_ssh_tunnel_method_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"tunnel_host": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through a jump server tunnel host using username and password authentication`,
											},
											"tunnel_port": schema.Int64Attribute{
												Computed: true,
											},
											"tunnel_user": schema.StringAttribute{
												Computed: true,
											},
											"tunnel_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_posthog": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"base_url": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"posthog",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_postmarkapp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"x_postmark_account_token": schema.StringAttribute{
								Computed: true,
							},
							"x_postmark_server_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"postmarkapp",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_prestashop": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"prestashop",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_public_apis": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"public-apis",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_punk_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"brewed_after": schema.StringAttribute{
								Computed: true,
							},
							"brewed_before": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"punk-api",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_pypi": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"project_name": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"pypi",
									),
								},
							},
							"version": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_qualaroo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"qualaroo",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"survey_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_quickbooks": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_quickbooks_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"realm_id": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"quickbooks",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_railz": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"railz",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_recharge": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"recharge",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_recreation": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"apikey": schema.StringAttribute{
								Computed: true,
							},
							"query_campsites": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"recreation",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_recruitee": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"company_id": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"recruitee",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_recurly": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"begin_time": schema.StringAttribute{
								Computed: true,
							},
							"end_time": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"recurly",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_redshift": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"redshift",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_retently": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_retently_authentication_mechanism_authenticate_via_retently_o_auth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Client",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Choose how to authenticate to Retently`,
									},
									"source_retently_authentication_mechanism_authenticate_with_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_key": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Token",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Choose how to authenticate to Retently`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"retently",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_rki_covid": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"rki-covid",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_rss": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"rss",
									),
								},
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_s3": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"dataset": schema.StringAttribute{
								Computed: true,
							},
							"format": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_s3_file_format_csv": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"additional_reader_options": schema.StringAttribute{
												Computed: true,
											},
											"advanced_options": schema.StringAttribute{
												Computed: true,
											},
											"block_size": schema.Int64Attribute{
												Computed: true,
											},
											"delimiter": schema.StringAttribute{
												Computed: true,
											},
											"double_quote": schema.BoolAttribute{
												Computed: true,
											},
											"encoding": schema.StringAttribute{
												Computed: true,
											},
											"escape_char": schema.StringAttribute{
												Computed: true,
											},
											"filetype": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"csv",
													),
												},
											},
											"infer_datatypes": schema.BoolAttribute{
												Computed: true,
											},
											"newlines_in_values": schema.BoolAttribute{
												Computed: true,
											},
											"quote_char": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `This connector utilises <a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank">PyArrow (Apache Arrow)</a> for CSV parsing.`,
									},
									"source_s3_file_format_parquet": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"batch_size": schema.Int64Attribute{
												Computed: true,
											},
											"buffer_size": schema.Int64Attribute{
												Computed: true,
											},
											"columns": schema.ListAttribute{
												Computed:    true,
												ElementType: types.StringType,
											},
											"filetype": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"parquet",
													),
												},
											},
										},
										Description: `This connector utilises <a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetFile.html" target="_blank">PyArrow (Apache Arrow)</a> for Parquet parsing.`,
									},
									"source_s3_file_format_avro": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"filetype": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"avro",
													),
												},
											},
										},
										Description: `This connector utilises <a href="https://fastavro.readthedocs.io/en/latest/" target="_blank">fastavro</a> for Avro parsing.`,
									},
									"source_s3_file_format_jsonl": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"block_size": schema.Int64Attribute{
												Computed: true,
											},
											"filetype": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"jsonl",
													),
												},
											},
											"newlines_in_values": schema.BoolAttribute{
												Computed: true,
											},
											"unexpected_field_behavior": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"ignore",
														"infer",
														"error",
													),
												},
												Description: `How JSON fields outside of explicit_schema (if given) are treated. Check <a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank">PyArrow documentation</a> for details`,
											},
										},
										Description: `This connector uses <a href="https://arrow.apache.org/docs/python/json.html" target="_blank">PyArrow</a> for JSON Lines (jsonl) file parsing.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"path_pattern": schema.StringAttribute{
								Computed: true,
							},
							"provider": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"aws_access_key_id": schema.StringAttribute{
										Computed: true,
									},
									"aws_secret_access_key": schema.StringAttribute{
										Computed: true,
									},
									"bucket": schema.StringAttribute{
										Computed: true,
									},
									"endpoint": schema.StringAttribute{
										Computed: true,
									},
									"path_prefix": schema.StringAttribute{
										Computed: true,
									},
								},
								Description: `Use this to load files from S3 or S3-compatible services`,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"s3",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_salesforce": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Client",
									),
								},
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"is_sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"salesforce",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"streams_criteria": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"criteria": schema.StringAttribute{
											Required: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"starts with",
													"ends with",
													"contains",
													"exacts",
													"starts not with",
													"ends not with",
													"not contains",
													"not exacts",
												),
											},
										},
										"value": schema.StringAttribute{
											Required: true,
										},
									},
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_salesforce_singer": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"BULK",
										"REST",
									),
								},
								Description: `Unless you know that you are transferring a very small amount of data, prefer using the BULK API. This will help avoid using up all of your API call quota with Salesforce. Valid values are BULK or REST.`,
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"is_sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"quota_percent_per_run": schema.NumberAttribute{
								Computed: true,
							},
							"quota_percent_total": schema.NumberAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"salesforce-singer",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_salesloft": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_salesloft_credentials_authenticate_via_o_auth": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									"source_salesloft_credentials_authenticate_via_api_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_key": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_key",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"salesloft",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sap_fieldglass": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sap-fieldglass",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_secoda": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"secoda",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sendgrid": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"apikey": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sendgrid",
									),
								},
							},
							"start_time": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sendinblue": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sendinblue",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_senseforce": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"backend_url": schema.StringAttribute{
								Computed: true,
							},
							"dataset_id": schema.StringAttribute{
								Computed: true,
							},
							"slice_range": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"senseforce",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sentry": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_token": schema.StringAttribute{
								Computed: true,
							},
							"discover_fields": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Validators: []validator.List{
									listvalidator.ValueStringsAre(validators.IsValidJSON()),
								},
							},
							"hostname": schema.StringAttribute{
								Computed: true,
							},
							"organization": schema.StringAttribute{
								Computed: true,
							},
							"project": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sentry",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sftp": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_sftp_authentication_wildcard_password_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_PASSWORD_AUTH",
													),
												},
												Description: `Connect through password authentication`,
											},
											"auth_user_password": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The server authentication method`,
									},
									"source_sftp_authentication_wildcard_ssh_key_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"SSH_KEY_AUTH",
													),
												},
												Description: `Connect through ssh key`,
											},
											"auth_ssh_key": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The server authentication method`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"file_pattern": schema.StringAttribute{
								Computed: true,
							},
							"file_types": schema.StringAttribute{
								Computed: true,
							},
							"folder_path": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sftp",
									),
								},
							},
							"user": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sftp_bulk": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"file_most_recent": schema.BoolAttribute{
								Computed: true,
							},
							"file_pattern": schema.StringAttribute{
								Computed: true,
							},
							"file_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"csv",
										"json",
									),
								},
								Description: `The file type you want to sync. Currently only 'csv' and 'json' files are supported.`,
							},
							"folder_path": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"port": schema.Int64Attribute{
								Computed: true,
							},
							"private_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sftp-bulk",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"stream_name": schema.StringAttribute{
								Computed: true,
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_shopify": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_shopify_shopify_authorization_method_api_password": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_password": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_password",
													),
												},
											},
										},
										Description: `API Password Auth`,
									},
									"source_shopify_shopify_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `OAuth2.0`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"shop": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"shopify",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_shortio": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"domain_id": schema.StringAttribute{
								Computed: true,
							},
							"secret_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"shortio",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_slack": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"channel_filter": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_slack_authentication_mechanism_sign_in_via_slack_o_auth_": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Default OAuth2.0 authorization",
													),
												},
											},
										},
										Description: `Choose how to authenticate into Slack`,
									},
									"source_slack_authentication_mechanism_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"option_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"API Token Credentials",
													),
												},
											},
										},
										Description: `Choose how to authenticate into Slack`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"join_channels": schema.BoolAttribute{
								Computed: true,
							},
							"lookback_window": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"slack",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_smaily": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_password": schema.StringAttribute{
								Computed: true,
							},
							"api_subdomain": schema.StringAttribute{
								Computed: true,
							},
							"api_username": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smaily",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_smartengage": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smartengage",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_smartsheets": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_smartsheets_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									"source_smartsheets_authorization_method_api_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smartsheets",
									),
								},
							},
							"spreadsheet_id": schema.StringAttribute{
								Computed: true,
							},
							"start_datetime": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_snapchat_marketing": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"snapchat-marketing",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_snowflake": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_snowflake_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_snowflake_authorization_method_username_and_password": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"username/password",
													),
												},
											},
											"password": schema.StringAttribute{
												Computed: true,
											},
											"username": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"host": schema.StringAttribute{
								Computed: true,
							},
							"jdbc_url_params": schema.StringAttribute{
								Computed: true,
							},
							"role": schema.StringAttribute{
								Computed: true,
							},
							"schema": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"snowflake",
									),
								},
							},
							"warehouse": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_sonar_cloud": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"component_keys": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Validators: []validator.List{
									listvalidator.ValueStringsAre(validators.IsValidJSON()),
								},
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"organization": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sonar-cloud",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"user_token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_spacex_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed: true,
							},
							"options": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"spacex-api",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_square": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_square_authentication_oauth_authentication": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"OAuth Credentials",
													),
												},
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Choose how to authenticate to Square.`,
									},
									"source_square_authentication_api_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_key": schema.StringAttribute{
												Computed: true,
											},
											"credentials_title": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"API Key",
													),
												},
											},
										},
										Description: `Choose how to authenticate to Square.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"include_deleted_objects": schema.BoolAttribute{
								Computed: true,
							},
							"is_sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"square",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_strava": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"athlete_id": schema.Int64Attribute{
								Computed: true,
							},
							"auth_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Client",
									),
								},
							},
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"strava",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_stripe": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"lookback_window_days": schema.Int64Attribute{
								Computed: true,
							},
							"slice_range": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"stripe",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_survey_sparrow": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_survey_sparrow_base_url_eu_based_account": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"url_base": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"https://eu-api.surveysparrow.com/v3",
													),
												},
											},
										},
										Description: `Is your account location is EU based? If yes, the base url to retrieve data will be different.`,
									},
									"source_survey_sparrow_base_url_global_account": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"url_base": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"https://api.surveysparrow.com/v3",
													),
												},
											},
										},
										Description: `Is your account location is EU based? If yes, the base url to retrieve data will be different.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"survey-sparrow",
									),
								},
							},
							"survey_id": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Validators: []validator.List{
									listvalidator.ValueStringsAre(validators.IsValidJSON()),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_surveymonkey": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"access_token": schema.StringAttribute{
										Computed: true,
									},
									"auth_method": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"oauth2.0",
											),
										},
									},
									"client_id": schema.StringAttribute{
										Computed: true,
									},
									"client_secret": schema.StringAttribute{
										Computed: true,
									},
								},
								Description: `The authorization method to use to retrieve data from SurveyMonkey`,
							},
							"origin": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"USA",
										"Europe",
										"Canada",
									),
								},
								Description: `Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different.`,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"surveymonkey",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"survey_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_tempo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"tempo",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_the_guardian_api": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
							},
							"query": schema.StringAttribute{
								Computed: true,
							},
							"section": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"the-guardian-api",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"tag": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_tiktok_marketing": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"attribution_window": schema.Int64Attribute{
								Computed: true,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_tiktok_marketing_authentication_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"advertiser_id": schema.StringAttribute{
												Computed: true,
											},
											"app_id": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"secret": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `Authentication method`,
									},
									"source_tiktok_marketing_authentication_method_sandbox_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"advertiser_id": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"sandbox_access_token",
													),
												},
											},
										},
										Description: `Authentication method`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"tiktok-marketing",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_todoist": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"todoist",
									),
								},
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_trello": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"board_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"key": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"trello",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_trustpilot": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"business_units": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_trustpilot_authorization_method_o_auth_2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
											"token_expiry_date": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									"source_trustpilot_authorization_method_api_key": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"apikey",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
										},
										Description: `The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"trustpilot",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_tvmaze_schedule": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"domestic_schedule_country_code": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"tvmaze-schedule",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"web_schedule_country_code": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_twilio": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_sid": schema.StringAttribute{
								Computed: true,
							},
							"auth_token": schema.StringAttribute{
								Computed: true,
							},
							"lookback_window": schema.Int64Attribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"twilio",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_twilio_taskrouter": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_sid": schema.StringAttribute{
								Computed: true,
							},
							"auth_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"twilio-taskrouter",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_twitter": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"query": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"twitter",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_typeform": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"form_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"typeform",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"token": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_us_census": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"query_params": schema.StringAttribute{
								Computed: true,
							},
							"query_path": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"us-census",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_vantage": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"vantage",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_webflow": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"site_id": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"webflow",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_whisky_hunter": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"whisky-hunter",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_wikipedia_pageviews": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"access": schema.StringAttribute{
								Computed: true,
							},
							"agent": schema.StringAttribute{
								Computed: true,
							},
							"article": schema.StringAttribute{
								Computed: true,
							},
							"country": schema.StringAttribute{
								Computed: true,
							},
							"end": schema.StringAttribute{
								Computed: true,
							},
							"project": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"wikipedia-pageviews",
									),
								},
							},
							"start": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_woocommerce": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Computed: true,
							},
							"api_secret": schema.StringAttribute{
								Computed: true,
							},
							"shop": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"woocommerce",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_xero": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"authentication": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"access_token": schema.StringAttribute{
										Computed: true,
									},
									"client_id": schema.StringAttribute{
										Computed: true,
									},
									"client_secret": schema.StringAttribute{
										Computed: true,
									},
									"refresh_token": schema.StringAttribute{
										Computed: true,
									},
									"token_expiry_date": schema.StringAttribute{
										Computed: true,
									},
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"xero",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"tenant_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_xkcd": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"xkcd",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_yandex_metrica": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"auth_token": schema.StringAttribute{
								Computed: true,
							},
							"counter_id": schema.StringAttribute{
								Computed: true,
							},
							"end_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"yandex-metrica",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsValidDate(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_younium": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"legal_entity": schema.StringAttribute{
								Computed: true,
							},
							"password": schema.StringAttribute{
								Computed: true,
							},
							"playground": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"younium",
									),
								},
							},
							"username": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_youtube_analytics": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"client_id": schema.StringAttribute{
										Computed: true,
									},
									"client_secret": schema.StringAttribute{
										Computed: true,
									},
									"refresh_token": schema.StringAttribute{
										Computed: true,
									},
									"additional_properties": schema.MapAttribute{
										Computed:    true,
										Optional:    true,
										ElementType: types.StringType,
										Validators: []validator.Map{
											mapvalidator.ValueStringsAre(validators.IsValidJSON()),
										},
									},
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"youtube-analytics",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zendesk_chat": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_zendesk_chat_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
											"credentials": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"refresh_token": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_zendesk_chat_authorization_method_access_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"credentials": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"access_token",
													),
												},
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zendesk-chat",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"subdomain": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zendesk_sunshine": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_zendesk_sunshine_authorization_method_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"client_id": schema.StringAttribute{
												Computed: true,
											},
											"client_secret": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									"source_zendesk_sunshine_authorization_method_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_method": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_token",
													),
												},
											},
											"email": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zendesk-sunshine",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"subdomain": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zendesk_support": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_zendesk_support_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"credentials": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Zendesk service provides two authentication methods. Choose between: ` + "`" + `OAuth2.0` + "`" + ` or ` + "`" + `API token` + "`" + `.`,
									},
									"source_zendesk_support_authentication_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"credentials": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_token",
													),
												},
											},
											"email": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Zendesk service provides two authentication methods. Choose between: ` + "`" + `OAuth2.0` + "`" + ` or ` + "`" + `API token` + "`" + `.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"ignore_pagination": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zendesk-support",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"subdomain": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zendesk_talk": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"credentials": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"source_zendesk_talk_authentication_api_token": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"api_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"api_token",
													),
												},
											},
											"email": schema.StringAttribute{
												Computed: true,
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Zendesk service provides two authentication methods. Choose between: ` + "`" + `OAuth2.0` + "`" + ` or ` + "`" + `API token` + "`" + `.`,
									},
									"source_zendesk_talk_authentication_o_auth2_0": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"access_token": schema.StringAttribute{
												Computed: true,
											},
											"auth_type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"oauth2.0",
													),
												},
											},
											"additional_properties": schema.MapAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Validators: []validator.Map{
													mapvalidator.ValueStringsAre(validators.IsValidJSON()),
												},
											},
										},
										Description: `Zendesk service provides two authentication methods. Choose between: ` + "`" + `OAuth2.0` + "`" + ` or ` + "`" + `API token` + "`" + `.`,
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zendesk-talk",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"subdomain": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zenloop": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"api_token": schema.StringAttribute{
								Computed: true,
							},
							"date_from": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zenloop",
									),
								},
							},
							"survey_group_id": schema.StringAttribute{
								Computed: true,
							},
							"survey_id": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zoho_crm": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"dc_region": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"US",
										"AU",
										"EU",
										"IN",
										"CN",
										"JP",
									),
								},
								Description: `Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>`,
							},
							"edition": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Free",
										"Standard",
										"Professional",
										"Enterprise",
										"Ultimate",
									),
								},
								Description: `Choose your Edition of Zoho CRM to determine API Concurrency Limits`,
							},
							"environment": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"Production",
										"Developer",
										"Sandbox",
									),
								},
								Description: `Please choose the environment`,
							},
							"refresh_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zoho-crm",
									),
								},
							},
							"start_datetime": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zoom": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"jwt_token": schema.StringAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zoom",
									),
								},
							},
						},
						Description: `The values required to configure the source.`,
					},
					"source_zuora": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"client_id": schema.StringAttribute{
								Computed: true,
							},
							"client_secret": schema.StringAttribute{
								Computed: true,
							},
							"is_sandbox": schema.BoolAttribute{
								Computed: true,
							},
							"source_type": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"zuora",
									),
								},
							},
							"start_date": schema.StringAttribute{
								Computed: true,
							},
							"window_in_days": schema.Int64Attribute{
								Computed: true,
							},
						},
						Description: `The values required to configure the source.`,
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"secret_id": schema.StringAttribute{
				Computed: true,
			},
			"source_id": schema.StringAttribute{
				Computed: true,
			},
			"source_type": schema.StringAttribute{
				Computed: true,
			},
			"workspace_id": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

func (r *SourceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SourceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SourceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToCreateSDKType()
	res, err := r.client.Sources.CreateSource(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.SourceResponse == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromCreateResponse(res.SourceResponse)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SourceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SourceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; we rely entirely on CREATE API request response

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SourceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *SourceResourceModel
	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SourceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SourceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	sourceID := data.SourceID.ValueString()
	request := operations.DeleteSourceRequest{
		SourceID: sourceID,
	}
	res, err := r.client.Sources.DeleteSource(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *SourceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
