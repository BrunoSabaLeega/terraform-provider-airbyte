// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceOracleUpdateConnectBySystemIDSIDConnectionType string

const (
	SourceOracleUpdateConnectBySystemIDSIDConnectionTypeSid SourceOracleUpdateConnectBySystemIDSIDConnectionType = "sid"
)

func (e SourceOracleUpdateConnectBySystemIDSIDConnectionType) ToPointer() *SourceOracleUpdateConnectBySystemIDSIDConnectionType {
	return &e
}

func (e *SourceOracleUpdateConnectBySystemIDSIDConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sid":
		*e = SourceOracleUpdateConnectBySystemIDSIDConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateConnectBySystemIDSIDConnectionType: %v", v)
	}
}

// SourceOracleUpdateConnectBySystemIDSID - Use SID (Oracle System Identifier)
type SourceOracleUpdateConnectBySystemIDSID struct {
	ConnectionType *SourceOracleUpdateConnectBySystemIDSIDConnectionType `json:"connection_type,omitempty"`
	Sid            string                                                `json:"sid"`
}

type SourceOracleUpdateConnectByServiceNameConnectionType string

const (
	SourceOracleUpdateConnectByServiceNameConnectionTypeServiceName SourceOracleUpdateConnectByServiceNameConnectionType = "service_name"
)

func (e SourceOracleUpdateConnectByServiceNameConnectionType) ToPointer() *SourceOracleUpdateConnectByServiceNameConnectionType {
	return &e
}

func (e *SourceOracleUpdateConnectByServiceNameConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "service_name":
		*e = SourceOracleUpdateConnectByServiceNameConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateConnectByServiceNameConnectionType: %v", v)
	}
}

// SourceOracleUpdateConnectByServiceName - Use service name
type SourceOracleUpdateConnectByServiceName struct {
	ConnectionType *SourceOracleUpdateConnectByServiceNameConnectionType `json:"connection_type,omitempty"`
	ServiceName    string                                                `json:"service_name"`
}

type SourceOracleUpdateConnectByType string

const (
	SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName SourceOracleUpdateConnectByType = "source-oracle-update_Connect by_Service name"
	SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID SourceOracleUpdateConnectByType = "source-oracle-update_Connect by_System ID (SID)"
)

type SourceOracleUpdateConnectBy struct {
	SourceOracleUpdateConnectByServiceName *SourceOracleUpdateConnectByServiceName
	SourceOracleUpdateConnectBySystemIDSID *SourceOracleUpdateConnectBySystemIDSID

	Type SourceOracleUpdateConnectByType
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateConnectByServiceName(sourceOracleUpdateConnectByServiceName SourceOracleUpdateConnectByServiceName) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateConnectByServiceName: &sourceOracleUpdateConnectByServiceName,
		Type:                                   typ,
	}
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateConnectBySystemIDSID(sourceOracleUpdateConnectBySystemIDSID SourceOracleUpdateConnectBySystemIDSID) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateConnectBySystemIDSID: &sourceOracleUpdateConnectBySystemIDSID,
		Type:                                   typ,
	}
}

func (u *SourceOracleUpdateConnectBy) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceOracleUpdateConnectByServiceName := new(SourceOracleUpdateConnectByServiceName)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateConnectByServiceName); err == nil {
		u.SourceOracleUpdateConnectByServiceName = sourceOracleUpdateConnectByServiceName
		u.Type = SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName
		return nil
	}

	sourceOracleUpdateConnectBySystemIDSID := new(SourceOracleUpdateConnectBySystemIDSID)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateConnectBySystemIDSID); err == nil {
		u.SourceOracleUpdateConnectBySystemIDSID = sourceOracleUpdateConnectBySystemIDSID
		u.Type = SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateConnectByServiceName != nil {
		return json.Marshal(u.SourceOracleUpdateConnectByServiceName)
	}

	if u.SourceOracleUpdateConnectBySystemIDSID != nil {
		return json.Marshal(u.SourceOracleUpdateConnectBySystemIDSID)
	}

	return nil, nil
}

type SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod string

const (
	SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethodEncryptedVerifyCertificate SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) ToPointer() *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod {
	return &e
}

func (e *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod: %v", v)
	}
}

// SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate struct {
	EncryptionMethod SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod `json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate string `json:"ssl_certificate"`
}

// SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm string

const (
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmAes256      SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "AES256"
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmRc456       SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "RC4_56"
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmThreeDes168 SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "3DES168"
)

func (e SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) ToPointer() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm {
	return &e
}

func (e *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm: %v", v)
	}
}

type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod string

const (
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethodClientNne SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod = "client_nne"
)

func (e SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod) ToPointer() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod {
	return &e
}

func (e *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod: %v", v)
	}
}

// SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm `json:"encryption_algorithm,omitempty"`
	EncryptionMethod    SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod     `json:"encryption_method"`
}

type SourceOracleUpdateEncryptionType string

const (
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE    SourceOracleUpdateEncryptionType = "source-oracle-update_Encryption_Native Network Encryption (NNE)"
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate SourceOracleUpdateEncryptionType = "source-oracle-update_Encryption_TLS Encrypted (verify certificate)"
)

type SourceOracleUpdateEncryption struct {
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE    *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
	SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate

	Type SourceOracleUpdateEncryptionType
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE(sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE: &sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate(sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate: &sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleUpdateEncryption) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE := new(SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE); err == nil {
		u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE = sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
		u.Type = SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
		return nil
	}

	sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate := new(SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate); err == nil {
		u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate = sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate
		u.Type = SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE != nil {
		return json.Marshal(u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE)
	}

	if u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate != nil {
		return json.Marshal(u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate)
	}

	return nil, nil
}

// SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod `json:"tunnel_method"`
}

type SourceOracleUpdateSSHTunnelMethodType string

const (
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel               SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_No Tunnel"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication   SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_SSH Key Authentication"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_Password Authentication"
)

type SourceOracleUpdateSSHTunnelMethod struct {
	SourceOracleUpdateSSHTunnelMethodNoTunnel               *SourceOracleUpdateSSHTunnelMethodNoTunnel
	SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication   *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
	SourceOracleUpdateSSHTunnelMethodPasswordAuthentication *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication

	Type SourceOracleUpdateSSHTunnelMethodType
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodNoTunnel(sourceOracleUpdateSSHTunnelMethodNoTunnel SourceOracleUpdateSSHTunnelMethodNoTunnel) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodNoTunnel: &sourceOracleUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication(sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication: &sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodPasswordAuthentication(sourceOracleUpdateSSHTunnelMethodPasswordAuthentication SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodPasswordAuthentication: &sourceOracleUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceOracleUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceOracleUpdateSSHTunnelMethodNoTunnel := new(SourceOracleUpdateSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateSSHTunnelMethodNoTunnel); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodNoTunnel = sourceOracleUpdateSSHTunnelMethodNoTunnel
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication := new(SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication = sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceOracleUpdateSSHTunnelMethodPasswordAuthentication := new(SourceOracleUpdateSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOracleUpdateSSHTunnelMethodPasswordAuthentication); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication = sourceOracleUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.SourceOracleUpdateSSHTunnelMethodNoTunnel)
	}

	if u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type SourceOracleUpdate struct {
	// Connect data that will be used for DB connection
	ConnectionData *SourceOracleUpdateConnectBy `json:"connection_data,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceOracleUpdateEncryption `json:"encryption"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
	Port int64 `json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}
