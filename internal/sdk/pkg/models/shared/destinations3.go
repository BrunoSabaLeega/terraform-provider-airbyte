// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationS3S3Enum string

const (
	DestinationS3S3EnumS3 DestinationS3S3Enum = "s3"
)

func (e DestinationS3S3Enum) ToPointer() *DestinationS3S3Enum {
	return &e
}

func (e *DestinationS3S3Enum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = DestinationS3S3Enum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3S3Enum: %v", v)
	}
}

// DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum - The compression algorithm used to compress data pages.
type DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum string

const (
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumUncompressed DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "UNCOMPRESSED"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumSnappy       DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "SNAPPY"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumGzip         DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "GZIP"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumLzo          DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "LZO"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumBrotli       DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "BROTLI"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumLz4          DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "LZ4"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnumZstd         DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum = "ZSTD"
)

func (e DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum) ToPointer() *DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum: %v", v)
	}
}

type DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum string

const (
	DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnumParquet DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum = "Parquet"
)

func (e DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum) ToPointer() *DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatParquetColumnarStorage - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `json:"block_size_mb,omitempty"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationS3OutputFormatParquetColumnarStorageCompressionCodecEnum `json:"compression_codec,omitempty"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                        `json:"dictionary_page_size_kb,omitempty"`
	FormatType           DestinationS3OutputFormatParquetColumnarStorageFormatTypeEnum `json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `json:"max_padding_size_mb,omitempty"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `json:"page_size_kb,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnumGzip DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum = "GZIP"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnumNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum = "No Compression"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON_Compression_No Compression"
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON_Compression_GZIP"
)

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	}

	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	}

	return nil, nil
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum - Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnumNoFlattening        DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum = "No flattening"
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnumRootLevelFlattening DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum = "Root level flattening"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum: %v", v)
	}
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnumJsonl DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum = "JSONL"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
	Flattening *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningEnum `json:"flattening,omitempty"`
	FormatType DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum  `json:"format_type"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnumGzip DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum = "GZIP"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnumNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum = "No Compression"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType = "destination-s3_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType = "destination-s3_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationS3OutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationS3OutputFormatCSVCommaSeparatedValuesCompression{
		DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationS3OutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationS3OutputFormatCSVCommaSeparatedValuesCompression{
		DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	}

	if u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	}

	return nil, nil
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum - Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnumNoFlattening        DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum = "No flattening"
	DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnumRootLevelFlattening DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum = "Root level flattening"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum: %v", v)
	}
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnumCsv DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum = "CSV"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValues - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationS3OutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningEnum `json:"flattening"`
	FormatType DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeEnum `json:"format_type"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnumSnappy DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum = "snappy"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnumZstandard DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum = "zstandard"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum `json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel int64 `json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `json:"include_checksum,omitempty"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnumXz DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum = "xz"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecEnum `json:"codec"`
	// See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel int64 `json:"compression_level"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnumBzip2 DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum = "bzip2"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnumDeflate DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum = "Deflate"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum `json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel int64 `json:"compression_level"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnumNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum = "no compression"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz            DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationS3OutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz            *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationS3OutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate(destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2(destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz(destinationS3OutputFormatAvroApacheAvroCompressionCodecXz DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz: &destinationS3OutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard(destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy(destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate = destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecXz); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz = destinationS3OutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard = destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy = destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy)
	}

	return nil, nil
}

type DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum string

const (
	DestinationS3OutputFormatAvroApacheAvroFormatTypeEnumAvro DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum = "Avro"
)

func (e DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum) ToPointer() *DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvro - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationS3OutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       DestinationS3OutputFormatAvroApacheAvroFormatTypeEnum   `json:"format_type"`
}

type DestinationS3OutputFormatType string

const (
	DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro                DestinationS3OutputFormatType = "destination-s3_Output Format_Avro: Apache Avro"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues       DestinationS3OutputFormatType = "destination-s3_Output Format_CSV: Comma-Separated Values"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON DestinationS3OutputFormatType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage        DestinationS3OutputFormatType = "destination-s3_Output Format_Parquet: Columnar Storage"
)

type DestinationS3OutputFormat struct {
	DestinationS3OutputFormatAvroApacheAvro                *DestinationS3OutputFormatAvroApacheAvro
	DestinationS3OutputFormatCSVCommaSeparatedValues       *DestinationS3OutputFormatCSVCommaSeparatedValues
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON
	DestinationS3OutputFormatParquetColumnarStorage        *DestinationS3OutputFormatParquetColumnarStorage

	Type DestinationS3OutputFormatType
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatAvroApacheAvro(destinationS3OutputFormatAvroApacheAvro DestinationS3OutputFormatAvroApacheAvro) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatAvroApacheAvro: &destinationS3OutputFormatAvroApacheAvro,
		Type:                                    typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatCSVCommaSeparatedValues(destinationS3OutputFormatCSVCommaSeparatedValues DestinationS3OutputFormatCSVCommaSeparatedValues) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatCSVCommaSeparatedValues: &destinationS3OutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON(destinationS3OutputFormatJSONLinesNewlineDelimitedJSON DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatParquetColumnarStorage(destinationS3OutputFormatParquetColumnarStorage DestinationS3OutputFormatParquetColumnarStorage) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatParquetColumnarStorage: &destinationS3OutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormat) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatAvroApacheAvro := new(DestinationS3OutputFormatAvroApacheAvro)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvro); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvro = destinationS3OutputFormatAvroApacheAvro
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro
		return nil
	}

	destinationS3OutputFormatCSVCommaSeparatedValues := new(DestinationS3OutputFormatCSVCommaSeparatedValues)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValues); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValues = destinationS3OutputFormatCSVCommaSeparatedValues
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSON); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON = destinationS3OutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationS3OutputFormatParquetColumnarStorage := new(DestinationS3OutputFormatParquetColumnarStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatParquetColumnarStorage); err == nil {
		u.DestinationS3OutputFormatParquetColumnarStorage = destinationS3OutputFormatParquetColumnarStorage
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatAvroApacheAvro != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvro)
	}

	if u.DestinationS3OutputFormatCSVCommaSeparatedValues != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValues)
	}

	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON)
	}

	if u.DestinationS3OutputFormatParquetColumnarStorage != nil {
		return json.Marshal(u.DestinationS3OutputFormatParquetColumnarStorage)
	}

	return nil, nil
}

// DestinationS3S3BucketRegionEnum - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3S3BucketRegionEnum string

const (
	DestinationS3S3BucketRegionEnumUnknown      DestinationS3S3BucketRegionEnum = ""
	DestinationS3S3BucketRegionEnumUsEast1      DestinationS3S3BucketRegionEnum = "us-east-1"
	DestinationS3S3BucketRegionEnumUsEast2      DestinationS3S3BucketRegionEnum = "us-east-2"
	DestinationS3S3BucketRegionEnumUsWest1      DestinationS3S3BucketRegionEnum = "us-west-1"
	DestinationS3S3BucketRegionEnumUsWest2      DestinationS3S3BucketRegionEnum = "us-west-2"
	DestinationS3S3BucketRegionEnumAfSouth1     DestinationS3S3BucketRegionEnum = "af-south-1"
	DestinationS3S3BucketRegionEnumApEast1      DestinationS3S3BucketRegionEnum = "ap-east-1"
	DestinationS3S3BucketRegionEnumApSouth1     DestinationS3S3BucketRegionEnum = "ap-south-1"
	DestinationS3S3BucketRegionEnumApNortheast1 DestinationS3S3BucketRegionEnum = "ap-northeast-1"
	DestinationS3S3BucketRegionEnumApNortheast2 DestinationS3S3BucketRegionEnum = "ap-northeast-2"
	DestinationS3S3BucketRegionEnumApNortheast3 DestinationS3S3BucketRegionEnum = "ap-northeast-3"
	DestinationS3S3BucketRegionEnumApSoutheast1 DestinationS3S3BucketRegionEnum = "ap-southeast-1"
	DestinationS3S3BucketRegionEnumApSoutheast2 DestinationS3S3BucketRegionEnum = "ap-southeast-2"
	DestinationS3S3BucketRegionEnumCaCentral1   DestinationS3S3BucketRegionEnum = "ca-central-1"
	DestinationS3S3BucketRegionEnumCnNorth1     DestinationS3S3BucketRegionEnum = "cn-north-1"
	DestinationS3S3BucketRegionEnumCnNorthwest1 DestinationS3S3BucketRegionEnum = "cn-northwest-1"
	DestinationS3S3BucketRegionEnumEuCentral1   DestinationS3S3BucketRegionEnum = "eu-central-1"
	DestinationS3S3BucketRegionEnumEuNorth1     DestinationS3S3BucketRegionEnum = "eu-north-1"
	DestinationS3S3BucketRegionEnumEuSouth1     DestinationS3S3BucketRegionEnum = "eu-south-1"
	DestinationS3S3BucketRegionEnumEuWest1      DestinationS3S3BucketRegionEnum = "eu-west-1"
	DestinationS3S3BucketRegionEnumEuWest2      DestinationS3S3BucketRegionEnum = "eu-west-2"
	DestinationS3S3BucketRegionEnumEuWest3      DestinationS3S3BucketRegionEnum = "eu-west-3"
	DestinationS3S3BucketRegionEnumSaEast1      DestinationS3S3BucketRegionEnum = "sa-east-1"
	DestinationS3S3BucketRegionEnumMeSouth1     DestinationS3S3BucketRegionEnum = "me-south-1"
	DestinationS3S3BucketRegionEnumUsGovEast1   DestinationS3S3BucketRegionEnum = "us-gov-east-1"
	DestinationS3S3BucketRegionEnumUsGovWest1   DestinationS3S3BucketRegionEnum = "us-gov-west-1"
)

func (e DestinationS3S3BucketRegionEnum) ToPointer() *DestinationS3S3BucketRegionEnum {
	return &e
}

func (e *DestinationS3S3BucketRegionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		*e = DestinationS3S3BucketRegionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3S3BucketRegionEnum: %v", v)
	}
}

// DestinationS3 - The values required to configure the destination.
type DestinationS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID     *string             `json:"access_key_id,omitempty"`
	DestinationType DestinationS3S3Enum `json:"destinationType"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format DestinationS3OutputFormat `json:"format"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath string `json:"s3_bucket_path"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion DestinationS3S3BucketRegionEnum `json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}
