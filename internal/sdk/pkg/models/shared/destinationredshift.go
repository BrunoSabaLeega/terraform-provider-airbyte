// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationRedshiftRedshift string

const (
	DestinationRedshiftRedshiftRedshift DestinationRedshiftRedshift = "redshift"
)

func (e DestinationRedshiftRedshift) ToPointer() *DestinationRedshiftRedshift {
	return &e
}

func (e *DestinationRedshiftRedshift) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redshift":
		*e = DestinationRedshiftRedshift(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftRedshift: %v", v)
	}
}

// DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedshiftSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod string

const (
	DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodNoTunnel DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// DestinationRedshiftSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethod `json:"tunnel_method"`
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_Password Authentication"
)

type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftSSHTunnelMethodNoTunnel               *DestinationRedshiftSSHTunnelMethodNoTunnel
	DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication   *DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication
	DestinationRedshiftSSHTunnelMethodPasswordAuthentication *DestinationRedshiftSSHTunnelMethodPasswordAuthentication

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodNoTunnel(destinationRedshiftSSHTunnelMethodNoTunnel DestinationRedshiftSSHTunnelMethodNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodNoTunnel: &destinationRedshiftSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication(destinationRedshiftSSHTunnelMethodSSHKeyAuthentication DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication: &destinationRedshiftSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodPasswordAuthentication(destinationRedshiftSSHTunnelMethodPasswordAuthentication DestinationRedshiftSSHTunnelMethodPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodPasswordAuthentication: &destinationRedshiftSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftSSHTunnelMethodNoTunnel := new(DestinationRedshiftSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodNoTunnel); err == nil {
		u.DestinationRedshiftSSHTunnelMethodNoTunnel = destinationRedshiftSSHTunnelMethodNoTunnel
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel
		return nil
	}

	destinationRedshiftSSHTunnelMethodSSHKeyAuthentication := new(DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication = destinationRedshiftSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationRedshiftSSHTunnelMethodPasswordAuthentication := new(DestinationRedshiftSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodPasswordAuthentication); err == nil {
		u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication = destinationRedshiftSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodNoTunnel)
	}

	if u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeAesCbcEnvelope DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType = "aes_cbc_envelope"
)

func (e DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType) ToPointer() *DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType {
	return &e
}

func (e *DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aes_cbc_envelope":
		*e = DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType: %v", v)
	}
}

// DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption - Staging data will be encrypted using AES-CBC envelope encryption.
type DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption struct {
	EncryptionType DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType `json:"encryption_type"`
	// The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
	KeyEncryptingKey *string `json:"key_encrypting_key,omitempty"`
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeNone DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType = "none"
)

func (e DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType) ToPointer() *DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType {
	return &e
}

func (e *DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType: %v", v)
	}
}

// DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption - Staging data will be stored in plaintext.
type DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption struct {
	EncryptionType DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType `json:"encryption_type"`
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionType string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption             DestinationRedshiftUploadingMethodS3StagingEncryptionType = "destination-redshift_Uploading Method_S3 Staging_Encryption_No encryption"
	DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionType = "destination-redshift_Uploading Method_S3 Staging_Encryption_AES-CBC envelope encryption"
)

type DestinationRedshiftUploadingMethodS3StagingEncryption struct {
	DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption             *DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
	DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption *DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	Type DestinationRedshiftUploadingMethodS3StagingEncryptionType
}

func CreateDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption(destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption) DestinationRedshiftUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption

	return DestinationRedshiftUploadingMethodS3StagingEncryption{
		DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption: &destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption,
		Type: typ,
	}
}

func CreateDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption(destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption) DestinationRedshiftUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	return DestinationRedshiftUploadingMethodS3StagingEncryption{
		DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption: &destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption,
		Type: typ,
	}
}

func (u *DestinationRedshiftUploadingMethodS3StagingEncryption) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption := new(DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption); err == nil {
		u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption = destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
		u.Type = DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
		return nil
	}

	destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption := new(DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption); err == nil {
		u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption = destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		u.Type = DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUploadingMethodS3StagingEncryption) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption)
	}

	if u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	}

	return nil, nil
}

type DestinationRedshiftUploadingMethodS3StagingMethod string

const (
	DestinationRedshiftUploadingMethodS3StagingMethodS3Staging DestinationRedshiftUploadingMethodS3StagingMethod = "S3 Staging"
)

func (e DestinationRedshiftUploadingMethodS3StagingMethod) ToPointer() *DestinationRedshiftUploadingMethodS3StagingMethod {
	return &e
}

func (e *DestinationRedshiftUploadingMethodS3StagingMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3 Staging":
		*e = DestinationRedshiftUploadingMethodS3StagingMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingMethod: %v", v)
	}
}

// DestinationRedshiftUploadingMethodS3StagingS3BucketRegion - The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
type DestinationRedshiftUploadingMethodS3StagingS3BucketRegion string

const (
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionUnknown      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = ""
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionUsEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "us-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionUsEast2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "us-east-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionUsWest1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "us-west-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionUsWest2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "us-west-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionAfSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "af-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApNortheast1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApNortheast2 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApNortheast3 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApSoutheast1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionApSoutheast2 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionCaCentral1   DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "ca-central-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionCnNorth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "cn-north-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionCnNorthwest1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuCentral1   DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-central-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuNorth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-north-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuWest1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-west-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuWest2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-west-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEuWest3      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "eu-west-3"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionSaEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "sa-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionMeSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegion = "me-south-1"
)

func (e DestinationRedshiftUploadingMethodS3StagingS3BucketRegion) ToPointer() *DestinationRedshiftUploadingMethodS3StagingS3BucketRegion {
	return &e
}

func (e *DestinationRedshiftUploadingMethodS3StagingS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		*e = DestinationRedshiftUploadingMethodS3StagingS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingS3BucketRegion: %v", v)
	}
}

// DestinationRedshiftUploadingMethodS3Staging - The method how the data will be uploaded to the database.
type DestinationRedshiftUploadingMethodS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// How to encrypt the staging data
	Encryption *DestinationRedshiftUploadingMethodS3StagingEncryption `json:"encryption,omitempty"`
	// Number of file buffers allocated for writing data. Increasing this number is beneficial for connections using Change Data Capture (CDC) and up to the number of streams within a connection. Increasing the number of file buffers past the maximum number of streams has deteriorating effects
	FileBufferCount *int64 `json:"file_buffer_count,omitempty"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string                                           `json:"file_name_pattern,omitempty"`
	Method          DestinationRedshiftUploadingMethodS3StagingMethod `json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `json:"purge_staging_data,omitempty"`
	// The name of the staging S3 bucket to use if utilising a COPY strategy. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
	S3BucketRegion DestinationRedshiftUploadingMethodS3StagingS3BucketRegion `json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

type DestinationRedshiftUploadingMethodStandardMethod string

const (
	DestinationRedshiftUploadingMethodStandardMethodStandard DestinationRedshiftUploadingMethodStandardMethod = "Standard"
)

func (e DestinationRedshiftUploadingMethodStandardMethod) ToPointer() *DestinationRedshiftUploadingMethodStandardMethod {
	return &e
}

func (e *DestinationRedshiftUploadingMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = DestinationRedshiftUploadingMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodStandardMethod: %v", v)
	}
}

// DestinationRedshiftUploadingMethodStandard - The method how the data will be uploaded to the database.
type DestinationRedshiftUploadingMethodStandard struct {
	Method DestinationRedshiftUploadingMethodStandardMethod `json:"method"`
}

type DestinationRedshiftUploadingMethodType string

const (
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard  DestinationRedshiftUploadingMethodType = "destination-redshift_Uploading Method_Standard"
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging DestinationRedshiftUploadingMethodType = "destination-redshift_Uploading Method_S3 Staging"
)

type DestinationRedshiftUploadingMethod struct {
	DestinationRedshiftUploadingMethodStandard  *DestinationRedshiftUploadingMethodStandard
	DestinationRedshiftUploadingMethodS3Staging *DestinationRedshiftUploadingMethodS3Staging

	Type DestinationRedshiftUploadingMethodType
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftUploadingMethodStandard(destinationRedshiftUploadingMethodStandard DestinationRedshiftUploadingMethodStandard) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftUploadingMethodStandard: &destinationRedshiftUploadingMethodStandard,
		Type: typ,
	}
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftUploadingMethodS3Staging(destinationRedshiftUploadingMethodS3Staging DestinationRedshiftUploadingMethodS3Staging) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftUploadingMethodS3Staging: &destinationRedshiftUploadingMethodS3Staging,
		Type: typ,
	}
}

func (u *DestinationRedshiftUploadingMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUploadingMethodStandard := new(DestinationRedshiftUploadingMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodStandard); err == nil {
		u.DestinationRedshiftUploadingMethodStandard = destinationRedshiftUploadingMethodStandard
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard
		return nil
	}

	destinationRedshiftUploadingMethodS3Staging := new(DestinationRedshiftUploadingMethodS3Staging)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3Staging); err == nil {
		u.DestinationRedshiftUploadingMethodS3Staging = destinationRedshiftUploadingMethodS3Staging
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUploadingMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUploadingMethodStandard != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodStandard)
	}

	if u.DestinationRedshiftUploadingMethodS3Staging != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3Staging)
	}

	return nil, nil
}

type DestinationRedshift struct {
	// Name of the database.
	Database        string                      `json:"database"`
	DestinationType DestinationRedshiftRedshift `json:"destinationType"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port int64 `json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema string `json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The method how the data will be uploaded to the database.
	UploadingMethod *DestinationRedshiftUploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}
