// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationRedshiftRedshiftEnum string

const (
	DestinationRedshiftRedshiftEnumRedshift DestinationRedshiftRedshiftEnum = "redshift"
)

func (e *DestinationRedshiftRedshiftEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "redshift":
		*e = DestinationRedshiftRedshiftEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftRedshiftEnum: %s", s)
	}
}

// DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum string

const (
	DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnumSSHPasswordAuth DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum = "SSH_PASSWORD_AUTH"
)

func (e *DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum: %s", s)
	}
}

// DestinationRedshiftSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod DestinationRedshiftSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum string

const (
	DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnumSSHKeyAuth DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum = "SSH_KEY_AUTH"
)

func (e *DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum: %s", s)
	}
}

// DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod DestinationRedshiftSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum - No ssh tunnel needed to connect to database
type DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum string

const (
	DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnumNoTunnel DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum = "NO_TUNNEL"
)

func (e *DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NO_TUNNEL":
		*e = DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum: %s", s)
	}
}

// DestinationRedshiftSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod DestinationRedshiftSSHTunnelMethodNoTunnelTunnelMethodEnum `json:"tunnel_method"`
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Tunnel Method_Password Authentication"
)

type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftSSHTunnelMethodNoTunnel               *DestinationRedshiftSSHTunnelMethodNoTunnel
	DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication   *DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication
	DestinationRedshiftSSHTunnelMethodPasswordAuthentication *DestinationRedshiftSSHTunnelMethodPasswordAuthentication

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodNoTunnel(destinationRedshiftSSHTunnelMethodNoTunnel DestinationRedshiftSSHTunnelMethodNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodNoTunnel: &destinationRedshiftSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication(destinationRedshiftSSHTunnelMethodSSHKeyAuthentication DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication: &destinationRedshiftSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHTunnelMethodPasswordAuthentication(destinationRedshiftSSHTunnelMethodPasswordAuthentication DestinationRedshiftSSHTunnelMethodPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHTunnelMethodPasswordAuthentication: &destinationRedshiftSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftSSHTunnelMethodNoTunnel := new(DestinationRedshiftSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodNoTunnel); err == nil {
		u.DestinationRedshiftSSHTunnelMethodNoTunnel = destinationRedshiftSSHTunnelMethodNoTunnel
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodNoTunnel
		return nil
	}

	destinationRedshiftSSHTunnelMethodSSHKeyAuthentication := new(DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication = destinationRedshiftSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationRedshiftSSHTunnelMethodPasswordAuthentication := new(DestinationRedshiftSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftSSHTunnelMethodPasswordAuthentication); err == nil {
		u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication = destinationRedshiftSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodNoTunnel)
	}

	if u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnumAesCbcEnvelope DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum = "aes_cbc_envelope"
)

func (e *DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "aes_cbc_envelope":
		*e = DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum: %s", s)
	}
}

// DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption - Staging data will be encrypted using AES-CBC envelope encryption.
type DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption struct {
	EncryptionType DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeEnum `json:"encryption_type"`
	// The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
	KeyEncryptingKey *string `json:"key_encrypting_key,omitempty"`
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnumNone DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum = "none"
)

func (e *DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "none":
		*e = DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum: %s", s)
	}
}

// DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption - Staging data will be stored in plaintext.
type DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption struct {
	EncryptionType DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeEnum `json:"encryption_type"`
}

type DestinationRedshiftUploadingMethodS3StagingEncryptionType string

const (
	DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption             DestinationRedshiftUploadingMethodS3StagingEncryptionType = "destination-redshift_Uploading Method_S3 Staging_Encryption_No encryption"
	DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionType = "destination-redshift_Uploading Method_S3 Staging_Encryption_AES-CBC envelope encryption"
)

type DestinationRedshiftUploadingMethodS3StagingEncryption struct {
	DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption             *DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
	DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption *DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	Type DestinationRedshiftUploadingMethodS3StagingEncryptionType
}

func CreateDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption(destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption) DestinationRedshiftUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption

	return DestinationRedshiftUploadingMethodS3StagingEncryption{
		DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption: &destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption,
		Type: typ,
	}
}

func CreateDestinationRedshiftUploadingMethodS3StagingEncryptionDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption(destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption) DestinationRedshiftUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	return DestinationRedshiftUploadingMethodS3StagingEncryption{
		DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption: &destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption,
		Type: typ,
	}
}

func (u *DestinationRedshiftUploadingMethodS3StagingEncryption) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption := new(DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption); err == nil {
		u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption = destinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
		u.Type = DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption
		return nil
	}

	destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption := new(DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption); err == nil {
		u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption = destinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		u.Type = DestinationRedshiftUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUploadingMethodS3StagingEncryption) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3StagingEncryptionNoEncryption)
	}

	if u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	}

	return nil, nil
}

type DestinationRedshiftUploadingMethodS3StagingMethodEnum string

const (
	DestinationRedshiftUploadingMethodS3StagingMethodEnumS3Staging DestinationRedshiftUploadingMethodS3StagingMethodEnum = "S3 Staging"
)

func (e *DestinationRedshiftUploadingMethodS3StagingMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "S3 Staging":
		*e = DestinationRedshiftUploadingMethodS3StagingMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingMethodEnum: %s", s)
	}
}

// DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum - The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
type DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum string

const (
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumUnknown      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = ""
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumUsEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "us-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumUsEast2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "us-east-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumUsWest1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "us-west-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumUsWest2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "us-west-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumAfSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "af-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApNortheast1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-northeast-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApNortheast2 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-northeast-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApNortheast3 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-northeast-3"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApSoutheast1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-southeast-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumApSoutheast2 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ap-southeast-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumCaCentral1   DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "ca-central-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumCnNorth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "cn-north-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumCnNorthwest1 DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "cn-northwest-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuCentral1   DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-central-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuNorth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-north-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-south-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuWest1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-west-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuWest2      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-west-2"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumEuWest3      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "eu-west-3"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumSaEast1      DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "sa-east-1"
	DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnumMeSouth1     DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum = "me-south-1"
)

func (e *DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		*e = DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum: %s", s)
	}
}

// DestinationRedshiftUploadingMethodS3Staging - The method how the data will be uploaded to the database.
type DestinationRedshiftUploadingMethodS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// How to encrypt the staging data
	Encryption *DestinationRedshiftUploadingMethodS3StagingEncryption `json:"encryption,omitempty"`
	// Number of file buffers allocated for writing data. Increasing this number is beneficial for connections using Change Data Capture (CDC) and up to the number of streams within a connection. Increasing the number of file buffers past the maximum number of streams has deteriorating effects
	FileBufferCount *int64 `json:"file_buffer_count,omitempty"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string                                               `json:"file_name_pattern,omitempty"`
	Method          DestinationRedshiftUploadingMethodS3StagingMethodEnum `json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `json:"purge_staging_data,omitempty"`
	// The name of the staging S3 bucket to use if utilising a COPY strategy. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
	S3BucketRegion DestinationRedshiftUploadingMethodS3StagingS3BucketRegionEnum `json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

type DestinationRedshiftUploadingMethodStandardMethodEnum string

const (
	DestinationRedshiftUploadingMethodStandardMethodEnumStandard DestinationRedshiftUploadingMethodStandardMethodEnum = "Standard"
)

func (e *DestinationRedshiftUploadingMethodStandardMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Standard":
		*e = DestinationRedshiftUploadingMethodStandardMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUploadingMethodStandardMethodEnum: %s", s)
	}
}

// DestinationRedshiftUploadingMethodStandard - The method how the data will be uploaded to the database.
type DestinationRedshiftUploadingMethodStandard struct {
	Method DestinationRedshiftUploadingMethodStandardMethodEnum `json:"method"`
}

type DestinationRedshiftUploadingMethodType string

const (
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard  DestinationRedshiftUploadingMethodType = "destination-redshift_Uploading Method_Standard"
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging DestinationRedshiftUploadingMethodType = "destination-redshift_Uploading Method_S3 Staging"
)

type DestinationRedshiftUploadingMethod struct {
	DestinationRedshiftUploadingMethodStandard  *DestinationRedshiftUploadingMethodStandard
	DestinationRedshiftUploadingMethodS3Staging *DestinationRedshiftUploadingMethodS3Staging

	Type DestinationRedshiftUploadingMethodType
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftUploadingMethodStandard(destinationRedshiftUploadingMethodStandard DestinationRedshiftUploadingMethodStandard) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftUploadingMethodStandard: &destinationRedshiftUploadingMethodStandard,
		Type: typ,
	}
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftUploadingMethodS3Staging(destinationRedshiftUploadingMethodS3Staging DestinationRedshiftUploadingMethodS3Staging) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftUploadingMethodS3Staging: &destinationRedshiftUploadingMethodS3Staging,
		Type: typ,
	}
}

func (u *DestinationRedshiftUploadingMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUploadingMethodStandard := new(DestinationRedshiftUploadingMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodStandard); err == nil {
		u.DestinationRedshiftUploadingMethodStandard = destinationRedshiftUploadingMethodStandard
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodStandard
		return nil
	}

	destinationRedshiftUploadingMethodS3Staging := new(DestinationRedshiftUploadingMethodS3Staging)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUploadingMethodS3Staging); err == nil {
		u.DestinationRedshiftUploadingMethodS3Staging = destinationRedshiftUploadingMethodS3Staging
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftUploadingMethodS3Staging
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUploadingMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUploadingMethodStandard != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodStandard)
	}

	if u.DestinationRedshiftUploadingMethodS3Staging != nil {
		return json.Marshal(u.DestinationRedshiftUploadingMethodS3Staging)
	}

	return nil, nil
}

// DestinationRedshift - The values required to configure the destination.
type DestinationRedshift struct {
	// Name of the database.
	Database        string                          `json:"database"`
	DestinationType DestinationRedshiftRedshiftEnum `json:"destinationType"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port int64 `json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema string `json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The method how the data will be uploaded to the database.
	UploadingMethod *DestinationRedshiftUploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}
