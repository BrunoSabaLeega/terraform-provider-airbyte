// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum string

const (
	SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnumWhileReadingData                 SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum = "While reading Data"
	SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnumAfterLoadingDataInTheDestination SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum = "After loading Data in the destination"
)

func (e SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum) ToPointer() *SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum {
	return &e
}

func (e *SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum: %v", v)
	}
}

type SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum string

const (
	SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnumCdc SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum = "CDC"
)

func (e SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum) ToPointer() *SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum {
	return &e
}

func (e *SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum: %v", v)
	}
}

// SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum - A logical decoding plugin installed on the PostgreSQL server.
type SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum string

const (
	SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnumPgoutput SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum = "pgoutput"
)

func (e SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum) ToPointer() *SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum {
	return &e
}

func (e *SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum: %v", v)
	}
}

// SourcePostgresReplicationMethodLogicalReplicationCDC - Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.
type SourcePostgresReplicationMethodLogicalReplicationCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `json:"initial_waiting_seconds,omitempty"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourcePostgresReplicationMethodLogicalReplicationCDCLSNCommitBehaviourEnum `json:"lsn_commit_behaviour,omitempty"`
	Method             SourcePostgresReplicationMethodLogicalReplicationCDCMethodEnum              `json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourcePostgresReplicationMethodLogicalReplicationCDCPluginEnum `json:"plugin,omitempty"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresReplicationMethodLogicalReplicationCDC SourcePostgresReplicationMethodLogicalReplicationCDC

func (c *SourcePostgresReplicationMethodLogicalReplicationCDC) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresReplicationMethodLogicalReplicationCDC{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresReplicationMethodLogicalReplicationCDC(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "initial_waiting_seconds")
	delete(additionalFields, "lsn_commit_behaviour")
	delete(additionalFields, "method")
	delete(additionalFields, "plugin")
	delete(additionalFields, "publication")
	delete(additionalFields, "replication_slot")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresReplicationMethodLogicalReplicationCDC) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresReplicationMethodLogicalReplicationCDC(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresReplicationMethodStandardMethodEnum string

const (
	SourcePostgresReplicationMethodStandardMethodEnumStandard SourcePostgresReplicationMethodStandardMethodEnum = "Standard"
)

func (e SourcePostgresReplicationMethodStandardMethodEnum) ToPointer() *SourcePostgresReplicationMethodStandardMethodEnum {
	return &e
}

func (e *SourcePostgresReplicationMethodStandardMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresReplicationMethodStandardMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresReplicationMethodStandardMethodEnum: %v", v)
	}
}

// SourcePostgresReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourcePostgresReplicationMethodStandard struct {
	Method SourcePostgresReplicationMethodStandardMethodEnum `json:"method"`
}

type SourcePostgresReplicationMethodType string

const (
	SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodStandard              SourcePostgresReplicationMethodType = "source-postgres_Replication Method_Standard"
	SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodLogicalReplicationCDC SourcePostgresReplicationMethodType = "source-postgres_Replication Method_Logical Replication (CDC)"
)

type SourcePostgresReplicationMethod struct {
	SourcePostgresReplicationMethodStandard              *SourcePostgresReplicationMethodStandard
	SourcePostgresReplicationMethodLogicalReplicationCDC *SourcePostgresReplicationMethodLogicalReplicationCDC

	Type SourcePostgresReplicationMethodType
}

func CreateSourcePostgresReplicationMethodSourcePostgresReplicationMethodStandard(sourcePostgresReplicationMethodStandard SourcePostgresReplicationMethodStandard) SourcePostgresReplicationMethod {
	typ := SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodStandard

	return SourcePostgresReplicationMethod{
		SourcePostgresReplicationMethodStandard: &sourcePostgresReplicationMethodStandard,
		Type:                                    typ,
	}
}

func CreateSourcePostgresReplicationMethodSourcePostgresReplicationMethodLogicalReplicationCDC(sourcePostgresReplicationMethodLogicalReplicationCDC SourcePostgresReplicationMethodLogicalReplicationCDC) SourcePostgresReplicationMethod {
	typ := SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodLogicalReplicationCDC

	return SourcePostgresReplicationMethod{
		SourcePostgresReplicationMethodLogicalReplicationCDC: &sourcePostgresReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func (u *SourcePostgresReplicationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourcePostgresReplicationMethodStandard := new(SourcePostgresReplicationMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresReplicationMethodStandard); err == nil {
		u.SourcePostgresReplicationMethodStandard = sourcePostgresReplicationMethodStandard
		u.Type = SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodStandard
		return nil
	}

	sourcePostgresReplicationMethodLogicalReplicationCDC := new(SourcePostgresReplicationMethodLogicalReplicationCDC)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresReplicationMethodLogicalReplicationCDC); err == nil {
		u.SourcePostgresReplicationMethodLogicalReplicationCDC = sourcePostgresReplicationMethodLogicalReplicationCDC
		u.Type = SourcePostgresReplicationMethodTypeSourcePostgresReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresReplicationMethodStandard != nil {
		return json.Marshal(u.SourcePostgresReplicationMethodStandard)
	}

	if u.SourcePostgresReplicationMethodLogicalReplicationCDC != nil {
		return json.Marshal(u.SourcePostgresReplicationMethodLogicalReplicationCDC)
	}

	return nil, nil
}

type SourcePostgresPostgresEnum string

const (
	SourcePostgresPostgresEnumPostgres SourcePostgresPostgresEnum = "postgres"
)

func (e SourcePostgresPostgresEnum) ToPointer() *SourcePostgresPostgresEnum {
	return &e
}

func (e *SourcePostgresPostgresEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = SourcePostgresPostgresEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPostgresEnum: %v", v)
	}
}

type SourcePostgresSSLModesVerifyFullModeEnum string

const (
	SourcePostgresSSLModesVerifyFullModeEnumVerifyFull SourcePostgresSSLModesVerifyFullModeEnum = "verify-full"
)

func (e SourcePostgresSSLModesVerifyFullModeEnum) ToPointer() *SourcePostgresSSLModesVerifyFullModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesVerifyFullModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresSSLModesVerifyFullModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesVerifyFullModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresSSLModesVerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                  `json:"client_key_password,omitempty"`
	Mode              SourcePostgresSSLModesVerifyFullModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesVerifyFull SourcePostgresSSLModesVerifyFull

func (c *SourcePostgresSSLModesVerifyFull) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesVerifyFull{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesVerifyFull(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "ca_certificate")
	delete(additionalFields, "client_certificate")
	delete(additionalFields, "client_key")
	delete(additionalFields, "client_key_password")
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesVerifyFull(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesVerifyCaModeEnum string

const (
	SourcePostgresSSLModesVerifyCaModeEnumVerifyCa SourcePostgresSSLModesVerifyCaModeEnum = "verify-ca"
)

func (e SourcePostgresSSLModesVerifyCaModeEnum) ToPointer() *SourcePostgresSSLModesVerifyCaModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesVerifyCaModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresSSLModesVerifyCaModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesVerifyCaModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresSSLModesVerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                `json:"client_key_password,omitempty"`
	Mode              SourcePostgresSSLModesVerifyCaModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesVerifyCa SourcePostgresSSLModesVerifyCa

func (c *SourcePostgresSSLModesVerifyCa) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesVerifyCa{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesVerifyCa(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "ca_certificate")
	delete(additionalFields, "client_certificate")
	delete(additionalFields, "client_key")
	delete(additionalFields, "client_key_password")
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesVerifyCa(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesRequireModeEnum string

const (
	SourcePostgresSSLModesRequireModeEnumRequire SourcePostgresSSLModesRequireModeEnum = "require"
)

func (e SourcePostgresSSLModesRequireModeEnum) ToPointer() *SourcePostgresSSLModesRequireModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesRequireModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresSSLModesRequireModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesRequireModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresSSLModesRequire struct {
	Mode SourcePostgresSSLModesRequireModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesRequire SourcePostgresSSLModesRequire

func (c *SourcePostgresSSLModesRequire) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesRequire{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesRequire(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesRequire) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesRequire(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesPreferModeEnum string

const (
	SourcePostgresSSLModesPreferModeEnumPrefer SourcePostgresSSLModesPreferModeEnum = "prefer"
)

func (e SourcePostgresSSLModesPreferModeEnum) ToPointer() *SourcePostgresSSLModesPreferModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesPreferModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresSSLModesPreferModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesPreferModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresSSLModesPrefer struct {
	Mode SourcePostgresSSLModesPreferModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesPrefer SourcePostgresSSLModesPrefer

func (c *SourcePostgresSSLModesPrefer) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesPrefer{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesPrefer(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesPrefer) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesPrefer(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesAllowModeEnum string

const (
	SourcePostgresSSLModesAllowModeEnumAllow SourcePostgresSSLModesAllowModeEnum = "allow"
)

func (e SourcePostgresSSLModesAllowModeEnum) ToPointer() *SourcePostgresSSLModesAllowModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesAllowModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresSSLModesAllowModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesAllowModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesAllow - Enables encryption only when required by the source database.
type SourcePostgresSSLModesAllow struct {
	Mode SourcePostgresSSLModesAllowModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesAllow SourcePostgresSSLModesAllow

func (c *SourcePostgresSSLModesAllow) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesAllow{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesAllow(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesAllow) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesAllow(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesDisableModeEnum string

const (
	SourcePostgresSSLModesDisableModeEnumDisable SourcePostgresSSLModesDisableModeEnum = "disable"
)

func (e SourcePostgresSSLModesDisableModeEnum) ToPointer() *SourcePostgresSSLModesDisableModeEnum {
	return &e
}

func (e *SourcePostgresSSLModesDisableModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresSSLModesDisableModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesDisableModeEnum: %v", v)
	}
}

// SourcePostgresSSLModesDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresSSLModesDisable struct {
	Mode SourcePostgresSSLModesDisableModeEnum `json:"mode"`

	AdditionalProperties map[string]interface{} `json:"-"`
}
type _SourcePostgresSSLModesDisable SourcePostgresSSLModesDisable

func (c *SourcePostgresSSLModesDisable) UnmarshalJSON(bs []byte) error {
	data := _SourcePostgresSSLModesDisable{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SourcePostgresSSLModesDisable(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "mode")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SourcePostgresSSLModesDisable) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SourcePostgresSSLModesDisable(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

type SourcePostgresSSLModesType string

const (
	SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable    SourcePostgresSSLModesType = "source-postgres_SSL Modes_disable"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow      SourcePostgresSSLModesType = "source-postgres_SSL Modes_allow"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer     SourcePostgresSSLModesType = "source-postgres_SSL Modes_prefer"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire    SourcePostgresSSLModesType = "source-postgres_SSL Modes_require"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa   SourcePostgresSSLModesType = "source-postgres_SSL Modes_verify-ca"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull SourcePostgresSSLModesType = "source-postgres_SSL Modes_verify-full"
)

type SourcePostgresSSLModes struct {
	SourcePostgresSSLModesDisable    *SourcePostgresSSLModesDisable
	SourcePostgresSSLModesAllow      *SourcePostgresSSLModesAllow
	SourcePostgresSSLModesPrefer     *SourcePostgresSSLModesPrefer
	SourcePostgresSSLModesRequire    *SourcePostgresSSLModesRequire
	SourcePostgresSSLModesVerifyCa   *SourcePostgresSSLModesVerifyCa
	SourcePostgresSSLModesVerifyFull *SourcePostgresSSLModesVerifyFull

	Type SourcePostgresSSLModesType
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesDisable(sourcePostgresSSLModesDisable SourcePostgresSSLModesDisable) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesDisable: &sourcePostgresSSLModesDisable,
		Type:                          typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesAllow(sourcePostgresSSLModesAllow SourcePostgresSSLModesAllow) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesAllow: &sourcePostgresSSLModesAllow,
		Type:                        typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesPrefer(sourcePostgresSSLModesPrefer SourcePostgresSSLModesPrefer) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesPrefer: &sourcePostgresSSLModesPrefer,
		Type:                         typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesRequire(sourcePostgresSSLModesRequire SourcePostgresSSLModesRequire) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesRequire: &sourcePostgresSSLModesRequire,
		Type:                          typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesVerifyCa(sourcePostgresSSLModesVerifyCa SourcePostgresSSLModesVerifyCa) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesVerifyCa: &sourcePostgresSSLModesVerifyCa,
		Type:                           typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesVerifyFull(sourcePostgresSSLModesVerifyFull SourcePostgresSSLModesVerifyFull) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesVerifyFull: &sourcePostgresSSLModesVerifyFull,
		Type:                             typ,
	}
}

func (u *SourcePostgresSSLModes) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourcePostgresSSLModesDisable := new(SourcePostgresSSLModesDisable)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesDisable); err == nil {
		u.SourcePostgresSSLModesDisable = sourcePostgresSSLModesDisable
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable
		return nil
	}

	sourcePostgresSSLModesAllow := new(SourcePostgresSSLModesAllow)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesAllow); err == nil {
		u.SourcePostgresSSLModesAllow = sourcePostgresSSLModesAllow
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow
		return nil
	}

	sourcePostgresSSLModesPrefer := new(SourcePostgresSSLModesPrefer)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesPrefer); err == nil {
		u.SourcePostgresSSLModesPrefer = sourcePostgresSSLModesPrefer
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer
		return nil
	}

	sourcePostgresSSLModesRequire := new(SourcePostgresSSLModesRequire)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesRequire); err == nil {
		u.SourcePostgresSSLModesRequire = sourcePostgresSSLModesRequire
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire
		return nil
	}

	sourcePostgresSSLModesVerifyCa := new(SourcePostgresSSLModesVerifyCa)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesVerifyCa); err == nil {
		u.SourcePostgresSSLModesVerifyCa = sourcePostgresSSLModesVerifyCa
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa
		return nil
	}

	sourcePostgresSSLModesVerifyFull := new(SourcePostgresSSLModesVerifyFull)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSLModesVerifyFull); err == nil {
		u.SourcePostgresSSLModesVerifyFull = sourcePostgresSSLModesVerifyFull
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresSSLModesDisable != nil {
		return json.Marshal(u.SourcePostgresSSLModesDisable)
	}

	if u.SourcePostgresSSLModesAllow != nil {
		return json.Marshal(u.SourcePostgresSSLModesAllow)
	}

	if u.SourcePostgresSSLModesPrefer != nil {
		return json.Marshal(u.SourcePostgresSSLModesPrefer)
	}

	if u.SourcePostgresSSLModesRequire != nil {
		return json.Marshal(u.SourcePostgresSSLModesRequire)
	}

	if u.SourcePostgresSSLModesVerifyCa != nil {
		return json.Marshal(u.SourcePostgresSSLModesVerifyCa)
	}

	if u.SourcePostgresSSLModesVerifyFull != nil {
		return json.Marshal(u.SourcePostgresSSLModesVerifyFull)
	}

	return nil, nil
}

// SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum string

const (
	SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnumSSHPasswordAuth SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum) ToPointer() *SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum string

const (
	SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnumSSHKeyAuth SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum = "SSH_KEY_AUTH"
)

func (e SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum) ToPointer() *SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum - No ssh tunnel needed to connect to database
type SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum string

const (
	SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnumNoTunnel SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum = "NO_TUNNEL"
)

func (e SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum) ToPointer() *SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodEnum `json:"tunnel_method"`
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel               SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_No Tunnel"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_SSH Key Authentication"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_Password Authentication"
)

type SourcePostgresSSHTunnelMethod struct {
	SourcePostgresSSHTunnelMethodNoTunnel               *SourcePostgresSSHTunnelMethodNoTunnel
	SourcePostgresSSHTunnelMethodSSHKeyAuthentication   *SourcePostgresSSHTunnelMethodSSHKeyAuthentication
	SourcePostgresSSHTunnelMethodPasswordAuthentication *SourcePostgresSSHTunnelMethodPasswordAuthentication

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodNoTunnel(sourcePostgresSSHTunnelMethodNoTunnel SourcePostgresSSHTunnelMethodNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodNoTunnel: &sourcePostgresSSHTunnelMethodNoTunnel,
		Type:                                  typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodSSHKeyAuthentication(sourcePostgresSSHTunnelMethodSSHKeyAuthentication SourcePostgresSSHTunnelMethodSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodSSHKeyAuthentication: &sourcePostgresSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodPasswordAuthentication(sourcePostgresSSHTunnelMethodPasswordAuthentication SourcePostgresSSHTunnelMethodPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodPasswordAuthentication: &sourcePostgresSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourcePostgresSSHTunnelMethodNoTunnel := new(SourcePostgresSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSHTunnelMethodNoTunnel); err == nil {
		u.SourcePostgresSSHTunnelMethodNoTunnel = sourcePostgresSSHTunnelMethodNoTunnel
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel
		return nil
	}

	sourcePostgresSSHTunnelMethodSSHKeyAuthentication := new(SourcePostgresSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication = sourcePostgresSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourcePostgresSSHTunnelMethodPasswordAuthentication := new(SourcePostgresSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourcePostgresSSHTunnelMethodPasswordAuthentication); err == nil {
		u.SourcePostgresSSHTunnelMethodPasswordAuthentication = sourcePostgresSSHTunnelMethodPasswordAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.SourcePostgresSSHTunnelMethodNoTunnel)
	}

	if u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.SourcePostgresSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.SourcePostgresSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

// SourcePostgres - The values required to configure the source.
type SourcePostgres struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port int64 `json:"port"`
	// Replication method for extracting data from the database.
	ReplicationMethod *SourcePostgresReplicationMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string                   `json:"schemas,omitempty"`
	SourceType SourcePostgresPostgresEnum `json:"sourceType"`
	// SSL connection modes. Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}
