// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod string

const (
	SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethodCdc SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod = "CDC"
)

func (e SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod) ToPointer() *SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod {
	return &e
}

func (e *SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod: %v", v)
	}
}

// SourceMysqlUpdateReplicationMethodLogicalReplicationCDC - CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
type SourceMysqlUpdateReplicationMethodLogicalReplicationCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64                                                        `json:"initial_waiting_seconds,omitempty"`
	Method                SourceMysqlUpdateReplicationMethodLogicalReplicationCDCMethod `json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimeZone *string `json:"server_time_zone,omitempty"`
}

type SourceMysqlUpdateReplicationMethodStandardMethod string

const (
	SourceMysqlUpdateReplicationMethodStandardMethodStandard SourceMysqlUpdateReplicationMethodStandardMethod = "STANDARD"
)

func (e SourceMysqlUpdateReplicationMethodStandardMethod) ToPointer() *SourceMysqlUpdateReplicationMethodStandardMethod {
	return &e
}

func (e *SourceMysqlUpdateReplicationMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlUpdateReplicationMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateReplicationMethodStandardMethod: %v", v)
	}
}

// SourceMysqlUpdateReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceMysqlUpdateReplicationMethodStandard struct {
	Method SourceMysqlUpdateReplicationMethodStandardMethod `json:"method"`
}

type SourceMysqlUpdateReplicationMethodType string

const (
	SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodStandard              SourceMysqlUpdateReplicationMethodType = "source-mysql-update_Replication Method_Standard"
	SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodLogicalReplicationCDC SourceMysqlUpdateReplicationMethodType = "source-mysql-update_Replication Method_Logical Replication (CDC)"
)

type SourceMysqlUpdateReplicationMethod struct {
	SourceMysqlUpdateReplicationMethodStandard              *SourceMysqlUpdateReplicationMethodStandard
	SourceMysqlUpdateReplicationMethodLogicalReplicationCDC *SourceMysqlUpdateReplicationMethodLogicalReplicationCDC

	Type SourceMysqlUpdateReplicationMethodType
}

func CreateSourceMysqlUpdateReplicationMethodSourceMysqlUpdateReplicationMethodStandard(sourceMysqlUpdateReplicationMethodStandard SourceMysqlUpdateReplicationMethodStandard) SourceMysqlUpdateReplicationMethod {
	typ := SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodStandard

	return SourceMysqlUpdateReplicationMethod{
		SourceMysqlUpdateReplicationMethodStandard: &sourceMysqlUpdateReplicationMethodStandard,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateReplicationMethodSourceMysqlUpdateReplicationMethodLogicalReplicationCDC(sourceMysqlUpdateReplicationMethodLogicalReplicationCDC SourceMysqlUpdateReplicationMethodLogicalReplicationCDC) SourceMysqlUpdateReplicationMethod {
	typ := SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodLogicalReplicationCDC

	return SourceMysqlUpdateReplicationMethod{
		SourceMysqlUpdateReplicationMethodLogicalReplicationCDC: &sourceMysqlUpdateReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateReplicationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlUpdateReplicationMethodStandard := new(SourceMysqlUpdateReplicationMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateReplicationMethodStandard); err == nil {
		u.SourceMysqlUpdateReplicationMethodStandard = sourceMysqlUpdateReplicationMethodStandard
		u.Type = SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodStandard
		return nil
	}

	sourceMysqlUpdateReplicationMethodLogicalReplicationCDC := new(SourceMysqlUpdateReplicationMethodLogicalReplicationCDC)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateReplicationMethodLogicalReplicationCDC); err == nil {
		u.SourceMysqlUpdateReplicationMethodLogicalReplicationCDC = sourceMysqlUpdateReplicationMethodLogicalReplicationCDC
		u.Type = SourceMysqlUpdateReplicationMethodTypeSourceMysqlUpdateReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlUpdateReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateReplicationMethodStandard != nil {
		return json.Marshal(u.SourceMysqlUpdateReplicationMethodStandard)
	}

	if u.SourceMysqlUpdateReplicationMethodLogicalReplicationCDC != nil {
		return json.Marshal(u.SourceMysqlUpdateReplicationMethodLogicalReplicationCDC)
	}

	return nil, nil
}

type SourceMysqlUpdateSSLModesVerifyIdentityMode string

const (
	SourceMysqlUpdateSSLModesVerifyIdentityModeVerifyIdentity SourceMysqlUpdateSSLModesVerifyIdentityMode = "verify_identity"
)

func (e SourceMysqlUpdateSSLModesVerifyIdentityMode) ToPointer() *SourceMysqlUpdateSSLModesVerifyIdentityMode {
	return &e
}

func (e *SourceMysqlUpdateSSLModesVerifyIdentityMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlUpdateSSLModesVerifyIdentityMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSLModesVerifyIdentityMode: %v", v)
	}
}

// SourceMysqlUpdateSSLModesVerifyIdentity - Always connect with SSL. Verify both CA and Hostname.
type SourceMysqlUpdateSSLModesVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                     `json:"client_key_password,omitempty"`
	Mode              SourceMysqlUpdateSSLModesVerifyIdentityMode `json:"mode"`
}

type SourceMysqlUpdateSSLModesVerifyCAMode string

const (
	SourceMysqlUpdateSSLModesVerifyCAModeVerifyCa SourceMysqlUpdateSSLModesVerifyCAMode = "verify_ca"
)

func (e SourceMysqlUpdateSSLModesVerifyCAMode) ToPointer() *SourceMysqlUpdateSSLModesVerifyCAMode {
	return &e
}

func (e *SourceMysqlUpdateSSLModesVerifyCAMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlUpdateSSLModesVerifyCAMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSLModesVerifyCAMode: %v", v)
	}
}

// SourceMysqlUpdateSSLModesVerifyCA - Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
type SourceMysqlUpdateSSLModesVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                               `json:"client_key_password,omitempty"`
	Mode              SourceMysqlUpdateSSLModesVerifyCAMode `json:"mode"`
}

type SourceMysqlUpdateSSLModesRequiredMode string

const (
	SourceMysqlUpdateSSLModesRequiredModeRequired SourceMysqlUpdateSSLModesRequiredMode = "required"
)

func (e SourceMysqlUpdateSSLModesRequiredMode) ToPointer() *SourceMysqlUpdateSSLModesRequiredMode {
	return &e
}

func (e *SourceMysqlUpdateSSLModesRequiredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlUpdateSSLModesRequiredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSLModesRequiredMode: %v", v)
	}
}

// SourceMysqlUpdateSSLModesRequired - Always connect with SSL. If the MySQL server doesn’t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
type SourceMysqlUpdateSSLModesRequired struct {
	Mode SourceMysqlUpdateSSLModesRequiredMode `json:"mode"`
}

type SourceMysqlUpdateSSLModesPreferredMode string

const (
	SourceMysqlUpdateSSLModesPreferredModePreferred SourceMysqlUpdateSSLModesPreferredMode = "preferred"
)

func (e SourceMysqlUpdateSSLModesPreferredMode) ToPointer() *SourceMysqlUpdateSSLModesPreferredMode {
	return &e
}

func (e *SourceMysqlUpdateSSLModesPreferredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlUpdateSSLModesPreferredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSLModesPreferredMode: %v", v)
	}
}

// SourceMysqlUpdateSSLModesPreferred - Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
type SourceMysqlUpdateSSLModesPreferred struct {
	Mode SourceMysqlUpdateSSLModesPreferredMode `json:"mode"`
}

type SourceMysqlUpdateSSLModesType string

const (
	SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesPreferred      SourceMysqlUpdateSSLModesType = "source-mysql-update_SSL modes_preferred"
	SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesRequired       SourceMysqlUpdateSSLModesType = "source-mysql-update_SSL modes_required"
	SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyCA       SourceMysqlUpdateSSLModesType = "source-mysql-update_SSL modes_Verify CA"
	SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyIdentity SourceMysqlUpdateSSLModesType = "source-mysql-update_SSL modes_Verify Identity"
)

type SourceMysqlUpdateSSLModes struct {
	SourceMysqlUpdateSSLModesPreferred      *SourceMysqlUpdateSSLModesPreferred
	SourceMysqlUpdateSSLModesRequired       *SourceMysqlUpdateSSLModesRequired
	SourceMysqlUpdateSSLModesVerifyCA       *SourceMysqlUpdateSSLModesVerifyCA
	SourceMysqlUpdateSSLModesVerifyIdentity *SourceMysqlUpdateSSLModesVerifyIdentity

	Type SourceMysqlUpdateSSLModesType
}

func CreateSourceMysqlUpdateSSLModesSourceMysqlUpdateSSLModesPreferred(sourceMysqlUpdateSSLModesPreferred SourceMysqlUpdateSSLModesPreferred) SourceMysqlUpdateSSLModes {
	typ := SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesPreferred

	return SourceMysqlUpdateSSLModes{
		SourceMysqlUpdateSSLModesPreferred: &sourceMysqlUpdateSSLModesPreferred,
		Type:                               typ,
	}
}

func CreateSourceMysqlUpdateSSLModesSourceMysqlUpdateSSLModesRequired(sourceMysqlUpdateSSLModesRequired SourceMysqlUpdateSSLModesRequired) SourceMysqlUpdateSSLModes {
	typ := SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesRequired

	return SourceMysqlUpdateSSLModes{
		SourceMysqlUpdateSSLModesRequired: &sourceMysqlUpdateSSLModesRequired,
		Type:                              typ,
	}
}

func CreateSourceMysqlUpdateSSLModesSourceMysqlUpdateSSLModesVerifyCA(sourceMysqlUpdateSSLModesVerifyCA SourceMysqlUpdateSSLModesVerifyCA) SourceMysqlUpdateSSLModes {
	typ := SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyCA

	return SourceMysqlUpdateSSLModes{
		SourceMysqlUpdateSSLModesVerifyCA: &sourceMysqlUpdateSSLModesVerifyCA,
		Type:                              typ,
	}
}

func CreateSourceMysqlUpdateSSLModesSourceMysqlUpdateSSLModesVerifyIdentity(sourceMysqlUpdateSSLModesVerifyIdentity SourceMysqlUpdateSSLModesVerifyIdentity) SourceMysqlUpdateSSLModes {
	typ := SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyIdentity

	return SourceMysqlUpdateSSLModes{
		SourceMysqlUpdateSSLModesVerifyIdentity: &sourceMysqlUpdateSSLModesVerifyIdentity,
		Type:                                    typ,
	}
}

func (u *SourceMysqlUpdateSSLModes) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlUpdateSSLModesPreferred := new(SourceMysqlUpdateSSLModesPreferred)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSLModesPreferred); err == nil {
		u.SourceMysqlUpdateSSLModesPreferred = sourceMysqlUpdateSSLModesPreferred
		u.Type = SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesPreferred
		return nil
	}

	sourceMysqlUpdateSSLModesRequired := new(SourceMysqlUpdateSSLModesRequired)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSLModesRequired); err == nil {
		u.SourceMysqlUpdateSSLModesRequired = sourceMysqlUpdateSSLModesRequired
		u.Type = SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesRequired
		return nil
	}

	sourceMysqlUpdateSSLModesVerifyCA := new(SourceMysqlUpdateSSLModesVerifyCA)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSLModesVerifyCA); err == nil {
		u.SourceMysqlUpdateSSLModesVerifyCA = sourceMysqlUpdateSSLModesVerifyCA
		u.Type = SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyCA
		return nil
	}

	sourceMysqlUpdateSSLModesVerifyIdentity := new(SourceMysqlUpdateSSLModesVerifyIdentity)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSLModesVerifyIdentity); err == nil {
		u.SourceMysqlUpdateSSLModesVerifyIdentity = sourceMysqlUpdateSSLModesVerifyIdentity
		u.Type = SourceMysqlUpdateSSLModesTypeSourceMysqlUpdateSSLModesVerifyIdentity
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateSSLModesPreferred != nil {
		return json.Marshal(u.SourceMysqlUpdateSSLModesPreferred)
	}

	if u.SourceMysqlUpdateSSLModesRequired != nil {
		return json.Marshal(u.SourceMysqlUpdateSSLModesRequired)
	}

	if u.SourceMysqlUpdateSSLModesVerifyCA != nil {
		return json.Marshal(u.SourceMysqlUpdateSSLModesVerifyCA)
	}

	if u.SourceMysqlUpdateSSLModesVerifyIdentity != nil {
		return json.Marshal(u.SourceMysqlUpdateSSLModesVerifyIdentity)
	}

	return nil, nil
}

// SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod SourceMysqlUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod SourceMysqlUpdateSSHTunnelMethodNoTunnelTunnelMethod `json:"tunnel_method"`
}

type SourceMysqlUpdateSSHTunnelMethodType string

const (
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodNoTunnel               SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_SSH Tunnel Method_No Tunnel"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication   SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_SSH Tunnel Method_SSH Key Authentication"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodPasswordAuthentication SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_SSH Tunnel Method_Password Authentication"
)

type SourceMysqlUpdateSSHTunnelMethod struct {
	SourceMysqlUpdateSSHTunnelMethodNoTunnel               *SourceMysqlUpdateSSHTunnelMethodNoTunnel
	SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication   *SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication
	SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication *SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication

	Type SourceMysqlUpdateSSHTunnelMethodType
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateSSHTunnelMethodNoTunnel(sourceMysqlUpdateSSHTunnelMethodNoTunnel SourceMysqlUpdateSSHTunnelMethodNoTunnel) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodNoTunnel

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateSSHTunnelMethodNoTunnel: &sourceMysqlUpdateSSHTunnelMethodNoTunnel,
		Type:                                     typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication(sourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication: &sourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateSSHTunnelMethodPasswordAuthentication(sourceMysqlUpdateSSHTunnelMethodPasswordAuthentication SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodPasswordAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication: &sourceMysqlUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlUpdateSSHTunnelMethodNoTunnel := new(SourceMysqlUpdateSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSHTunnelMethodNoTunnel); err == nil {
		u.SourceMysqlUpdateSSHTunnelMethodNoTunnel = sourceMysqlUpdateSSHTunnelMethodNoTunnel
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	sourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication := new(SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication = sourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceMysqlUpdateSSHTunnelMethodPasswordAuthentication := new(SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlUpdateSSHTunnelMethodPasswordAuthentication); err == nil {
		u.SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication = sourceMysqlUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.SourceMysqlUpdateSSHTunnelMethodNoTunnel)
	}

	if u.SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.SourceMysqlUpdateSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.SourceMysqlUpdateSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type SourceMysqlUpdate struct {
	// The database name.
	Database string `json:"database"`
	// The host name of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port to connect to.
	Port int64 `json:"port"`
	// Replication method to use for extracting data from the database.
	ReplicationMethod SourceMysqlUpdateReplicationMethod `json:"replication_method"`
	// SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
	SslMode *SourceMysqlUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}
