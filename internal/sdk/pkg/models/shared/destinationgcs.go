// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationGcsAuthenticationHMACKeyCredentialTypeEnum string

const (
	DestinationGcsAuthenticationHMACKeyCredentialTypeEnumHmacKey DestinationGcsAuthenticationHMACKeyCredentialTypeEnum = "HMAC_KEY"
)

func (e *DestinationGcsAuthenticationHMACKeyCredentialTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "HMAC_KEY":
		*e = DestinationGcsAuthenticationHMACKeyCredentialTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsAuthenticationHMACKeyCredentialTypeEnum: %s", s)
	}
}

// DestinationGcsAuthenticationHMACKey - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsAuthenticationHMACKey struct {
	CredentialType DestinationGcsAuthenticationHMACKeyCredentialTypeEnum `json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

type DestinationGcsAuthenticationType string

const (
	DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey DestinationGcsAuthenticationType = "destination-gcs_Authentication_HMAC Key"
)

type DestinationGcsAuthentication struct {
	DestinationGcsAuthenticationHMACKey *DestinationGcsAuthenticationHMACKey

	Type DestinationGcsAuthenticationType
}

func CreateDestinationGcsAuthenticationDestinationGcsAuthenticationHMACKey(destinationGcsAuthenticationHMACKey DestinationGcsAuthenticationHMACKey) DestinationGcsAuthentication {
	typ := DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey

	return DestinationGcsAuthentication{
		DestinationGcsAuthenticationHMACKey: &destinationGcsAuthenticationHMACKey,
		Type:                                typ,
	}
}

func (u *DestinationGcsAuthentication) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsAuthenticationHMACKey := new(DestinationGcsAuthenticationHMACKey)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsAuthenticationHMACKey); err == nil {
		u.DestinationGcsAuthenticationHMACKey = destinationGcsAuthenticationHMACKey
		u.Type = DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsAuthenticationHMACKey != nil {
		return json.Marshal(u.DestinationGcsAuthenticationHMACKey)
	}

	return nil, nil
}

type DestinationGcsGcsEnum string

const (
	DestinationGcsGcsEnumGcs DestinationGcsGcsEnum = "gcs"
)

func (e *DestinationGcsGcsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "gcs":
		*e = DestinationGcsGcsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsGcsEnum: %s", s)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum - The compression algorithm used to compress data pages.
type DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum string

const (
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumUncompressed DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "UNCOMPRESSED"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumSnappy       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "SNAPPY"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumGzip         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "GZIP"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumLzo          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "LZO"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumBrotli       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "BROTLI"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumLz4          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "LZ4"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnumZstd         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum = "ZSTD"
)

func (e *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum: %s", s)
	}
}

type DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum string

const (
	DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnumParquet DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum = "Parquet"
)

func (e *DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Parquet":
		*e = DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorage - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `json:"block_size_mb,omitempty"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecEnum `json:"compression_codec,omitempty"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                         `json:"dictionary_page_size_kb,omitempty"`
	FormatType           DestinationGcsOutputFormatParquetColumnarStorageFormatTypeEnum `json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `json:"max_padding_size_mb,omitempty"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `json:"page_size_kb,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnumGzip DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum = "GZIP"
)

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "GZIP":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnumNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum = "No Compression"
)

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "No Compression":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_No Compression"
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_GZIP"
)

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	}

	return nil, nil
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnumJsonl DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum = "JSONL"
)

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "JSONL":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression   `json:"compression,omitempty"`
	FormatType  DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeEnum `json:"format_type"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnumGzip DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum = "GZIP"
)

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "GZIP":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnumNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum = "No Compression"
)

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "No Compression":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeEnum `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	}

	return nil, nil
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnumNoFlattening        DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum = "No flattening"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnumRootLevelFlattening DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum = "Root level flattening"
)

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum: %s", s)
	}
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnumCsv DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum = "CSV"
)

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "CSV":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValues - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationEnum `json:"flattening,omitempty"`
	FormatType DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeEnum     `json:"format_type"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnumSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum = "snappy"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "snappy":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecEnum `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnumZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum = "zstandard"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "zstandard":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecEnum `json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `json:"include_checksum,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnumXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum = "xz"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "xz":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecEnum `json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnumBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum = "bzip2"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "bzip2":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecEnum `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnumDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum = "Deflate"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Deflate":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecEnum `json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnumNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum = "no compression"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "no compression":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecEnum `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate(destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2(destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz(destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard(destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy(destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate = destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz = destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard = destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy = destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy)
	}

	return nil, nil
}

type DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum string

const (
	DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnumAvro DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum = "Avro"
)

func (e *DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Avro":
		*e = DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum: %s", s)
	}
}

// DestinationGcsOutputFormatAvroApacheAvro - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsOutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       DestinationGcsOutputFormatAvroApacheAvroFormatTypeEnum   `json:"format_type"`
}

type DestinationGcsOutputFormatType string

const (
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro                DestinationGcsOutputFormatType = "destination-gcs_Output Format_Avro: Apache Avro"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues       DestinationGcsOutputFormatType = "destination-gcs_Output Format_CSV: Comma-Separated Values"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage        DestinationGcsOutputFormatType = "destination-gcs_Output Format_Parquet: Columnar Storage"
)

type DestinationGcsOutputFormat struct {
	DestinationGcsOutputFormatAvroApacheAvro                *DestinationGcsOutputFormatAvroApacheAvro
	DestinationGcsOutputFormatCSVCommaSeparatedValues       *DestinationGcsOutputFormatCSVCommaSeparatedValues
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
	DestinationGcsOutputFormatParquetColumnarStorage        *DestinationGcsOutputFormatParquetColumnarStorage

	Type DestinationGcsOutputFormatType
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatAvroApacheAvro(destinationGcsOutputFormatAvroApacheAvro DestinationGcsOutputFormatAvroApacheAvro) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatAvroApacheAvro: &destinationGcsOutputFormatAvroApacheAvro,
		Type:                                     typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatCSVCommaSeparatedValues(destinationGcsOutputFormatCSVCommaSeparatedValues DestinationGcsOutputFormatCSVCommaSeparatedValues) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatCSVCommaSeparatedValues: &destinationGcsOutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatParquetColumnarStorage(destinationGcsOutputFormatParquetColumnarStorage DestinationGcsOutputFormatParquetColumnarStorage) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatParquetColumnarStorage: &destinationGcsOutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormat) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatAvroApacheAvro := new(DestinationGcsOutputFormatAvroApacheAvro)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvro); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvro = destinationGcsOutputFormatAvroApacheAvro
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValues := new(DestinationGcsOutputFormatCSVCommaSeparatedValues)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValues); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValues = destinationGcsOutputFormatCSVCommaSeparatedValues
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationGcsOutputFormatParquetColumnarStorage := new(DestinationGcsOutputFormatParquetColumnarStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatParquetColumnarStorage); err == nil {
		u.DestinationGcsOutputFormatParquetColumnarStorage = destinationGcsOutputFormatParquetColumnarStorage
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvro != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvro)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValues != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValues)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON)
	}

	if u.DestinationGcsOutputFormatParquetColumnarStorage != nil {
		return json.Marshal(u.DestinationGcsOutputFormatParquetColumnarStorage)
	}

	return nil, nil
}

// DestinationGCSGCSBucketRegionEnum - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSGCSBucketRegionEnum string

const (
	DestinationGCSGCSBucketRegionEnumNorthamericaNortheast1 DestinationGCSGCSBucketRegionEnum = "northamerica-northeast1"
	DestinationGCSGCSBucketRegionEnumNorthamericaNortheast2 DestinationGCSGCSBucketRegionEnum = "northamerica-northeast2"
	DestinationGCSGCSBucketRegionEnumUsCentral1             DestinationGCSGCSBucketRegionEnum = "us-central1"
	DestinationGCSGCSBucketRegionEnumUsEast1                DestinationGCSGCSBucketRegionEnum = "us-east1"
	DestinationGCSGCSBucketRegionEnumUsEast4                DestinationGCSGCSBucketRegionEnum = "us-east4"
	DestinationGCSGCSBucketRegionEnumUsWest1                DestinationGCSGCSBucketRegionEnum = "us-west1"
	DestinationGCSGCSBucketRegionEnumUsWest2                DestinationGCSGCSBucketRegionEnum = "us-west2"
	DestinationGCSGCSBucketRegionEnumUsWest3                DestinationGCSGCSBucketRegionEnum = "us-west3"
	DestinationGCSGCSBucketRegionEnumUsWest4                DestinationGCSGCSBucketRegionEnum = "us-west4"
	DestinationGCSGCSBucketRegionEnumSouthamericaEast1      DestinationGCSGCSBucketRegionEnum = "southamerica-east1"
	DestinationGCSGCSBucketRegionEnumSouthamericaWest1      DestinationGCSGCSBucketRegionEnum = "southamerica-west1"
	DestinationGCSGCSBucketRegionEnumEuropeCentral2         DestinationGCSGCSBucketRegionEnum = "europe-central2"
	DestinationGCSGCSBucketRegionEnumEuropeNorth1           DestinationGCSGCSBucketRegionEnum = "europe-north1"
	DestinationGCSGCSBucketRegionEnumEuropeWest1            DestinationGCSGCSBucketRegionEnum = "europe-west1"
	DestinationGCSGCSBucketRegionEnumEuropeWest2            DestinationGCSGCSBucketRegionEnum = "europe-west2"
	DestinationGCSGCSBucketRegionEnumEuropeWest3            DestinationGCSGCSBucketRegionEnum = "europe-west3"
	DestinationGCSGCSBucketRegionEnumEuropeWest4            DestinationGCSGCSBucketRegionEnum = "europe-west4"
	DestinationGCSGCSBucketRegionEnumEuropeWest6            DestinationGCSGCSBucketRegionEnum = "europe-west6"
	DestinationGCSGCSBucketRegionEnumAsiaEast1              DestinationGCSGCSBucketRegionEnum = "asia-east1"
	DestinationGCSGCSBucketRegionEnumAsiaEast2              DestinationGCSGCSBucketRegionEnum = "asia-east2"
	DestinationGCSGCSBucketRegionEnumAsiaNortheast1         DestinationGCSGCSBucketRegionEnum = "asia-northeast1"
	DestinationGCSGCSBucketRegionEnumAsiaNortheast2         DestinationGCSGCSBucketRegionEnum = "asia-northeast2"
	DestinationGCSGCSBucketRegionEnumAsiaNortheast3         DestinationGCSGCSBucketRegionEnum = "asia-northeast3"
	DestinationGCSGCSBucketRegionEnumAsiaSouth1             DestinationGCSGCSBucketRegionEnum = "asia-south1"
	DestinationGCSGCSBucketRegionEnumAsiaSouth2             DestinationGCSGCSBucketRegionEnum = "asia-south2"
	DestinationGCSGCSBucketRegionEnumAsiaSoutheast1         DestinationGCSGCSBucketRegionEnum = "asia-southeast1"
	DestinationGCSGCSBucketRegionEnumAsiaSoutheast2         DestinationGCSGCSBucketRegionEnum = "asia-southeast2"
	DestinationGCSGCSBucketRegionEnumAustraliaSoutheast1    DestinationGCSGCSBucketRegionEnum = "australia-southeast1"
	DestinationGCSGCSBucketRegionEnumAustraliaSoutheast2    DestinationGCSGCSBucketRegionEnum = "australia-southeast2"
	DestinationGCSGCSBucketRegionEnumAsia                   DestinationGCSGCSBucketRegionEnum = "asia"
	DestinationGCSGCSBucketRegionEnumEu                     DestinationGCSGCSBucketRegionEnum = "eu"
	DestinationGCSGCSBucketRegionEnumUs                     DestinationGCSGCSBucketRegionEnum = "us"
	DestinationGCSGCSBucketRegionEnumAsia1                  DestinationGCSGCSBucketRegionEnum = "asia1"
	DestinationGCSGCSBucketRegionEnumEur4                   DestinationGCSGCSBucketRegionEnum = "eur4"
	DestinationGCSGCSBucketRegionEnumNam4                   DestinationGCSGCSBucketRegionEnum = "nam4"
)

func (e *DestinationGCSGCSBucketRegionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSGCSBucketRegionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSGCSBucketRegionEnum: %s", s)
	}
}

// DestinationGcs - The values required to configure the destination.
type DestinationGcs struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential      DestinationGcsAuthentication `json:"credential"`
	DestinationType DestinationGcsGcsEnum        `json:"destinationType"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSGCSBucketRegionEnum `json:"gcs_bucket_region,omitempty"`
}
